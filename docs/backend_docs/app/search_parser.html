<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>app.search_parser API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>app.search_parser</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import abc
from enum import Enum
from typing import List, Union, Optional, Dict

from bson import ObjectId
from flask_pymongo import PyMongo

from app.database_impl.attrib_options import AttributeOption
from app.database_impl.tags import Tag


class Brackets(Enum):
    &#34;&#34;&#34;
    An enum class used to enumerate the two types of parthenthsis 
    and to be able to just lookup their character representations
    &#34;&#34;&#34;

    Parentheses = [&#34;Parentheses&#34;, &#39;(&#39;, &#39;)&#39;]
    Curly = [&#34;Curly&#34;, &#39;{&#39;, &#39;}&#39;]


class SearchStringParseError:
    &#34;&#34;&#34;
    A base class used to repersent the a general error that might 
    be returned by the parser
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return &#34;SearchStringParseError: &#34;

    def __repr__(self) -&gt; str:
        return self.__str__()


class UnexpectedCloseBracket(SearchStringParseError):
    &#34;&#34;&#34;
    A subclass of SearchStringParseError, for the specific instance 
    where a close baracket (either } or )) was encountered in an 
    illegal/unexpected position such as &#39;(a ::and b))&#39;
    &#34;&#34;&#34;

    def __init__(self, index: int, bracket: Brackets):
        self.index = index
        self.bracket = bracket

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Unexpected &#39;&#34; + self.bracket.value[2] + &#34;&#39; at index: &#34; + str(self.index)


class MissingCloseBracket(SearchStringParseError):
    &#34;&#34;&#34;
    A subclass of SearchStringParseError, for the specific instance 
    where a close baracket (either } or )) was missing, where is 
    was required such as &#39;(a :: and b&#39;
    &#34;&#34;&#34;

    def __init__(self, bracket: Brackets):
        self.bracket = bracket

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Missing a closing &#39;&#34; + self.bracket.value[2] + &#34;&#39;&#34;


class UnexpectedOperator(SearchStringParseError):
    &#34;&#34;&#34;
    A subclass of SearchStringParseError, for the specific instance 
    where an operator such as ::and occurs in an unexpected locations 
    such as: &#39;a ::and ::and b&#39;
    &#34;&#34;&#34;

    def __init__(self, index: int, operator: &#39;OperatorTypes&#39;, alias=None):
        self.index = index
        if alias is None or not alias:
            self.operator_str = &#34;::&#34; + str(operator.value)
        else:
            self.operator_str = alias

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Unexpected operator: [&#34; + self.operator_str + &#34;] at index: &#34; + str(self.index)


class UnexpectedTag(SearchStringParseError):
    &#34;&#34;&#34;
    A subclass of SearchStringParseError, for the specific instance 
    where a tag appears in the wrong spot such as: &#39;a ::not b&#39;
    &#34;&#34;&#34;

    def __init__(self, index: int, string: str):
        self.index = index
        self.string = string

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Unexpected tag: [&#34; + self.string + &#34;] at index: &#34; + str(self.index)


class NonexistentTag(SearchStringParseError):
    &#34;&#34;&#34;
    A subclass of SearchStringParseError, for the specific instance 
    where a tag does not exisit in the DB
    &#34;&#34;&#34;

    def __init__(self, string: str):
        self.string = string

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Nonexistent tag: [&#34; + self.string + &#34;]&#34;


class NonexistentAttribute(SearchStringParseError):
    &#34;&#34;&#34;
    A subclass of SearchStringParseError, for the specific instance 
    where an attribute does not exisit in the DBA subclass of 
    SearchStringParseError, for the specific instance where an attribute 
    does not exisit in the DB
    &#34;&#34;&#34;

    def __init__(self, string: str):
        self.string = string

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Nonexistent attribute: [&#34; + self.string + &#34;]&#34;


class Value:
    &#34;&#34;&#34;
    An general &#39;atom&#39; of an expression, such as &#39;a&#39; or 
    &#39;::instance::uuid::equals::10202901&#39;
    &#34;&#34;&#34;

    string: str
    not_value: bool = False

    @staticmethod
    def parse(value: str) -&gt; Union[&#39;Value&#39;, SearchStringParseError]:
        &#34;&#34;&#34;
        Given a string, that is suppose to figure out which kind 
        of atom/value it is and parse that into it&#39;s types
        &#34;&#34;&#34;

        if value.lstrip().startswith(&#34;::&#34;):

            if value.lstrip().startswith(&#34;::has::&#34;):
                cls = HasItemAttributeValue()
                cls.string = value
                cls.attribute_name = value.lstrip()[len(&#34;::has::&#34;):].rstrip().lower()

                return cls
            elif value.lstrip().startswith(&#34;::instance::has::&#34;):
                cls = HasInstanceAttributeValue()
                cls.string = value
                cls.attribute_name = value.lstrip()[len(&#34;::instance::has::&#34;):].rstrip().lstrip()

                return cls
            elif value.lstrip().startswith(&#34;::instance::&#34;):
                remain = value.lstrip()[len(&#34;::instance::&#34;):].rstrip()

                if &#34;::equals::&#34; in remain:
                    s = remain.find(&#34;::equals::&#34;)

                    cls = CheckInstanceAttributeValue()
                    cls.string = value
                    cls.attribute_name = remain[:s].lower()
                    cls.value = remain[s + len(&#34;::equals::&#34;):]
                    cls.check_mode = CheckMode.Equals

                    return cls
                elif &#34;::contains::&#34; in remain:
                    s = remain.find(&#34;::contains::&#34;)

                    cls = CheckInstanceAttributeValue()
                    cls.string = value
                    cls.attribute_name = remain[:s].lower()
                    cls.value = remain[s + len(&#34;::contains::&#34;):]
                    cls.check_mode = CheckMode.Contains

                    return cls
                else:
                    cls = InstanceTagValue()
                    cls.string = value
                    cls.stripped_name = remain.strip().lower()

                    return cls

            else:
                remain = value.lstrip()[len(&#34;::&#34;):].rstrip()

                if &#34;::equals::&#34; in remain:
                    s = remain.find(&#34;::equals::&#34;)

                    cls = CheckItemAttributeValue()
                    cls.string = value
                    cls.attribute_name = remain[:s].lower()
                    cls.value = remain[s + len(&#34;::equals::&#34;):]
                    cls.check_mode = CheckMode.Equals

                    return cls
                elif &#34;::contains::&#34; in remain:
                    s = remain.find(&#34;::contains::&#34;)

                    cls = CheckItemAttributeValue()
                    cls.string = value
                    cls.attribute_name = remain[:s].lower()
                    cls.value = remain[s + len(&#34;::contains::&#34;):]
                    cls.check_mode = CheckMode.Contains

                    return cls

        else:
            cls = ItemTagValue()
            cls.string = value
            cls.stripped_name = value.strip().lower()

            return cls

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Convert the atom back into a string, for testing
        &#34;&#34;&#34;
        if self.not_value:
            return &#34;!&#34;
        return &#34;&#34;

    def to_search_query(self) -&gt; Dict:
        &#34;&#34;&#34;
        Take the value/atom and convert it into a MongoDB search 
        query for that specific information
        &#34;&#34;&#34;
        if isinstance(self, ItemTagValue):
            if self.not_value:
                inner = {&#34;$ne&#34;: self.tag_id}
                op = &#34;$and&#34;
            else:
                inner = self.tag_id
                op = &#34;$or&#34;

            return {op: [{&#34;tags&#34;: inner}, {&#34;implied_tags&#34;: inner}]}
        elif isinstance(self, InstanceTagValue):
            if self.not_value:
                inner = {&#34;$ne&#34;: self.tag_id}
                op = &#34;$and&#34;
            else:
                inner = self.tag_id
                op = &#34;$or&#34;

            return {op: [{&#34;instances.tags&#34;: inner}, {&#34;instances.implied_tags&#34;: inner}]}
        elif isinstance(self, HasItemAttributeValue):
            if self.not_value:
                return {&#34;attributes.option_id&#34;: {&#34;$ne&#34;: self.attribute_option_id}}
            else:
                return {&#34;attributes.option_id&#34;: self.attribute_option_id}
        elif isinstance(self, HasInstanceAttributeValue):
            if self.not_value:
                return {&#34;instances.attributes.option_id&#34;: {&#34;$ne&#34;: self.attribute_option_id}}
            else:
                return {&#34;instances.attributes.option_id&#34;: self.attribute_option_id}
        elif isinstance(self, VisibleItemValue):
            return {&#34;hidden&#34;: {&#34;$ne&#34;: True}}
        elif isinstance(self, CheckItemAttributeValue):
            if self.check_mode == CheckMode.Equals:
                if self.not_value:
                    return {&#34;attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;$ne&#34;: self.value}}}}
                else:
                    return {&#34;attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: self.value}}}
            elif self.check_mode == CheckMode.Contains:
                if self.not_value:
                    return {&#34;attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;not&#34;: {&#34;$regex&#34;: &#34;.*&#34; + self.value + &#34;.*&#34;}}}}}
                else:
                    return {&#34;attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;$regex&#34;: &#34;.*&#34; + self.value + &#34;.*&#34;}}}}
            else:
                return {&#34;TODO&#34;: &#34;Unexpected&#34;}
        elif isinstance(self, CheckInstanceAttributeValue):
            if self.check_mode == CheckMode.Equals:
                if self.not_value:
                    return {&#34;instances.attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;$ne&#34;: self.value}}}}
                else:
                    return {&#34;instances.attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: self.value}}}
            elif self.check_mode == CheckMode.Contains:
                if self.not_value:
                    return {&#34;instances.attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;not&#34;: {&#34;$regex&#34;: &#34;.*&#34; + self.value + &#34;.*&#34;}}}}}
                else:
                    return {&#34;instances.attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;$regex&#34;: &#34;.*&#34; + self.value + &#34;.*&#34;}}}}
            else:
                return {&#34;TODO&#34;: &#34;Unexpected&#34;}


class TagValue(Value):
    &#34;&#34;&#34;
    A subclass of Value, for the specific case where the atom is 
    a tag, like &#39;a&#39;
    &#34;&#34;&#34;
    stripped_name: str
    tag_id: Optional[ObjectId] = None

    def __str__(self) -&gt; str:
        return super().__str__()


class ItemTagValue(TagValue):
    &#34;&#34;&#34;
    A subclass of TagValue, for the specific case where the tag is 
    for a tag attached to an item, like &#39;a&#39;  
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Tag: &#39;&#34; + self.stripped_name + &#34;&#39;&#34;


class InstanceTagValue(TagValue):
    &#34;&#34;&#34;
    A subclass of TagValue, for the specific case where the tag is 
    for a tag attached to an instance, like &#39;instance::a&#39;
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;InstanceTag: &#39;&#34; + self.stripped_name + &#34;&#39;&#34;


class AttributeValue(Value):
    &#34;&#34;&#34;
    A subclass of Value, for the specific case where we are looking 
    for an attribute
    &#34;&#34;&#34;

    attribute_name: str
    attribute_option_id: Optional[ObjectId] = None

    def __str__(self) -&gt; str:
        return super().__str__()


class HasItemAttributeValue(AttributeValue):
    &#34;&#34;&#34;
    A subclass of AttributeValue, for when we are looking for an item 
    to have an attribute, like: &#39;has::name&#39;
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;HasItemAttribute: &#39;&#34; + self.attribute_name + &#34;&#39;&#34;


class HasInstanceAttributeValue(AttributeValue):
    &#34;&#34;&#34;
    A subclass of AttributeValue, for when we are looking for an instance 
    to have an attribute, like: &#39;instance::has::name&#39;
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;HasInstanceAttribute: &#39;&#34; + self.attribute_name + &#34;&#39;&#34;


class CheckMode(Enum):
    &#34;&#34;&#34;
    For the value checks below, enumerates whether it is &#39;equals&#39; or &#39;contains&#39;
    &#34;&#34;&#34;

    Equals = 0,
    Contains = 1
    # TODO add more options? such as starts with/ends with, or case sensitive/case insensitive


class CheckItemAttributeValue(AttributeValue):
    &#34;&#34;&#34;
    A subclass of AttributeValue, for when checking for a specific 
    value of an item&#39;s attribute, like &#39;name::equals::Bob&#39; or &#39;name::contains::Bob&#39;
    &#34;&#34;&#34;

    check_mode: CheckMode
    value: str

    def __str__(self) -&gt; str:
        return &#34;CheckItemAttribute: &#39;&#34; + self.attribute_name + &#34;&#39;&#34; + &#34; | &#34; + str(
            self.check_mode) + &#34; | &#39;&#34; + self.value + &#34;&#39;&#34;


class CheckInstanceAttributeValue(AttributeValue):
    &#34;&#34;&#34;
    A subclass of AttributeValue, for when checking for a specific 
    value of an instance&#39;s attribute, like &#39;name::equals::Bob&#39; or 
    &#39;name::contains::Bob&#39;
    &#34;&#34;&#34;

    check_mode: CheckMode
    value: str

    def __str__(self) -&gt; str:
        return &#34;CheckInstanceAttribute: &#39;&#34; + self.attribute_name + &#34;&#39;&#34; + &#34; | &#34; + str(
            self.check_mode) + &#34; | &#39;&#34; + self.value + &#34;&#39;&#34;


class VisibleItemValue(Value):
    &#34;&#34;&#34;
    A special subclass of Value, used internally to tell the DB to only 
    provide visible visible items/instances from the DB
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return &#34;VisibleItem&#34;


class OperatorTypes(Enum):
    &#34;&#34;&#34;
    An enum to enumerate the different types of operator
    &#34;&#34;&#34;

    Identity = &#34;identity&#34;
    Not = &#34;not&#34;
    And = &#34;and&#34;
    Or = &#34;or&#34;


class Operator(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;
    A general base class for the two types of operator (unitary, binary) 
    as a node in a abstact symbol tree of operators and values on the leafs
    &#34;&#34;&#34;

    op_type: OperatorTypes = None

    def __init__(self, op_type: OperatorTypes):
        self.op_type = op_type

    @abc.abstractmethod
    def get_left_most(self) -&gt; Union[&#39;Operator&#39;, Value]:
        &#34;&#34;&#34;
        Get the left most child of this node
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def get_right_most(self) -&gt; Union[&#39;Operator&#39;, Value]:
        &#34;&#34;&#34;
        Get the right most child of this node
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def set_left_most(self, value: Union[&#39;Operator&#39;, Value]):
        &#34;&#34;&#34;
        Set the left most child of this node
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def set_right_most(self, value: Union[&#39;Operator&#39;, Value]):
        &#34;&#34;&#34;
        Set the right most child of this node
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Convert back to string for debugging
        &#34;&#34;&#34; 
        pass

    @abc.abstractmethod
    def to_search_query(self) -&gt; Dict:
        &#34;&#34;&#34;
        Recursively convert this node and it&#39;s children to a MongoDB query
        &#34;&#34;&#34;
        pass


class UnitaryOperator(Operator):
    &#34;&#34;&#34;
    A subclass of Operator for the specific instance of an operator 
    that takes in one value, such as &#39;not&#39; or the unity operator &#39;()&#39;
    &#34;&#34;&#34;
    value: Union[Operator, Value]

    def __init__(self, op_type: OperatorTypes, value: Union[Operator, Value]):
        super().__init__(op_type)

        self.value = value

    def get_left_most(self) -&gt; Union[Operator, Value]:
        &#34;&#34;&#34;
        Get the left most child of this node
        &#34;&#34;&#34;
        return self.value

    def get_right_most(self) -&gt; Union[Operator, Value]:
        &#34;&#34;&#34;
        Get the right most child of this node
        &#34;&#34;&#34;
        return self.value

    def set_left_most(self, value: Union[Operator, Value]):
        &#34;&#34;&#34;
        Set the left most child of this node
        &#34;&#34;&#34;
        self.value = value

    def set_right_most(self, value: Union[Operator, Value]):
        &#34;&#34;&#34;
        Set the right most child of this node
        &#34;&#34;&#34;
        self.value = value

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Convert back to string for debugging
        &#34;&#34;&#34;
        if self.op_type == OperatorTypes.Identity:
            return &#34;(&#34; + str(self.value) + &#34;)&#34;
        else:
            return &#34;::not &#34; + str(self.value)

    def to_search_query(self) -&gt; Dict:
        &#34;&#34;&#34;
        Recursively convert this node and it&#39;s children to a MongoDB query
        &#34;&#34;&#34;
        if self.op_type == OperatorTypes.Identity:
            return self.value.to_search_query()
        else:
            return {&#34;NOTE&#34;: &#34;Should never be reached&#34;}


class BinaryOperator(Operator):
    &#34;&#34;&#34;
    A subclass of Operator for the specific instance of an operator 
    that takes in two values, such as &#39;and&#39; or &#39;or&#39;
    &#34;&#34;&#34;

    left_value: Union[Operator, Value]
    right_value: Union[Operator, Value]

    def __init__(self, op_type: OperatorTypes, left_value: Union[Operator, Value], right_value: Union[Operator, Value]):
        super().__init__(op_type)

        self.left_value = left_value
        self.right_value = right_value

    def get_left_most(self) -&gt; Union[Operator, Value]:
        &#34;&#34;&#34;
        Get the left most child of this node
        &#34;&#34;&#34;
        return self.left_value

    def get_right_most(self) -&gt; Union[Operator, Value]:
        &#34;&#34;&#34;
        Get the right most child of this node
        &#34;&#34;&#34;
        return self.right_value

    def set_left_most(self, value: Union[Operator, Value]):
        &#34;&#34;&#34;
        Set the left most child of this node
        &#34;&#34;&#34;
        self.left_value = value

    def set_right_most(self, value: Union[Operator, Value]):
        &#34;&#34;&#34;
        Set the right most child of this node
        &#34;&#34;&#34;
        self.right_value = value

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Convert back to string for debugging
        &#34;&#34;&#34;
        if self.op_type == OperatorTypes.And:
            return &#34;(&#34; + str(self.left_value) + &#34; ::and &#34; + str(self.right_value) + &#34;)&#34;
        else:
            return &#34;(&#34; + str(self.left_value) + &#34; ::or &#34; + str(self.right_value) + &#34;)&#34;

    def to_search_query(self) -&gt; Dict:
        &#34;&#34;&#34;
        Recursively convert this node and it&#39;s children to a MongoDB query
        &#34;&#34;&#34;
        if self.op_type == OperatorTypes.And:
            return {&#34;$and&#34;: [self.left_value.to_search_query(), self.right_value.to_search_query()]}
        else:
            return {&#34;$or&#34;: [self.left_value.to_search_query(), self.right_value.to_search_query()]}


class Parentheses:
    start: int = -1
    end: int = -1
    inner: List[&#39;Parentheses&#39;] = []

    def __init__(self, start: int, end: int, inner: List[&#39;Parentheses&#39;]):
        self.start = start
        self.end = end
        self.inner = inner

    def __str__(self) -&gt; str:
        inner_str = &#34;&#34;

        first = True
        for i in self.inner:
            if first:
                first = False
            else:
                inner_str += &#34;, &#34;
            inner_str += str(i)

        return &#34;Parentheses: start = &#34; + str(self.start) + &#34;, end = &#34; + str(self.end) + &#34;, inner = [&#34; + inner_str + &#34;]&#34;


class LexerSymbolTypes(Enum):
    &#34;&#34;&#34;
    An enum used to represent all the different symbols that the lexer 
    must proccess, along with their character representations, and array
    of string represents an alias
    &#34;&#34;&#34;

    # Operators
    AND = [&#34;::and&#34;, &#39;,&#39;]
    OR = &#34;::or&#34;
    NOT = [&#34;::not&#34;, &#39;-&#39;]
    # Brackets
    PAREN_OPEN = &#34;(&#34;
    PAREN_CLOSE = &#34;)&#34;
    ESCAPE_OPEN = &#34;{&#34;
    ESCAPE_CLOSE = &#34;}&#34;
    # Tags
    TAG = None
    IGNORE = &#34;&#34;

    @staticmethod
    def from_str(value: str) -&gt; &#39;LexerSymbolTypes&#39;:
        &#34;&#34;&#34;
        Convert a string into a lexer symbol type based on theirt string representations
        &#34;&#34;&#34;

        for option in LexerSymbolTypes:
            if isinstance(option.value, list):
                for o in option.value:
                    if o == value:
                        return option
            else:
                if option.value == value:
                    return option
        return LexerSymbolTypes.TAG


class LexerSymbol:
    &#34;&#34;&#34;
    A class used by the lexer to store the symbols it extracts
    &#34;&#34;&#34;

    symbol_type: LexerSymbolTypes
    start_index: int
    end_index: int

    def __init__(self, symbol_type: LexerSymbolTypes, start_index: int, end_index: int):
        self.symbol_type = symbol_type
        self.start_index = start_index
        self.end_index = end_index

    def __str__(self) -&gt; str:
        if isinstance(self.symbol_type.value, list):
            symbol_str = self.symbol_type.value[0]
        elif self.symbol_type.value is not None:
            symbol_str = self.symbol_type.value
        else:
            symbol_str = &#34;::TAG&#34;

        return &#34;[&#34; + str(self.start_index) + &#34;, &#34; + str(self.end_index) + &#34;]&#34; + symbol_str


#  a lexer to turn the string into an array of symbols
def search_string_lexer(search_string: str) -&gt; Union[List[LexerSymbol], SearchStringParseError]:
    &#34;&#34;&#34;
    Takes in a search string and converts it intl an array of lexer symbols
    &#34;&#34;&#34;

    result = []

    escape_depth = 0
    paren_depth = 0
    symbol_start = 0
    skipped = False

    for i, c in enumerate(search_string):

        if c == &#39;{&#39;:
            escape_depth += 1

            if escape_depth == 1:
                if search_string[symbol_start:i].isspace():
                    # result.append(
                    #     LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))

                    result.append(LexerSymbol(LexerSymbolTypes.ESCAPE_OPEN, i, i))
                    symbol_start = i + 1

                    skipped = False
                else:
                    skipped = True

        elif c == &#39;}&#39;:
            escape_depth -= 1

            if escape_depth == 0 and not skipped:
                result.append(LexerSymbol(LexerSymbolTypes.TAG, symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.ESCAPE_CLOSE, i, i))

                symbol_start = i + 1
            elif escape_depth &lt; 0:
                return UnexpectedCloseBracket(i, Brackets.Curly)
        elif escape_depth == 0:
            if c == &#39;(&#39; or c == &#39;)&#39;:
                if c == &#39;(&#39;:
                    paren_depth += 1
                else:
                    paren_depth -= 1

                    if paren_depth &lt; 0:
                        return UnexpectedCloseBracket(i, Brackets.Parentheses)

                result.append(
                    LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.from_str(c), i, i))
                symbol_start = i + 1

            if c == &#39;,&#39;:
                result.append(
                    LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.AND, i, i))
                symbol_start = i + 1

            if search_string[i:].startswith(&#34;::and&#34;):
                result.append(
                    LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.AND, i, i + 4))
                symbol_start = i + 5

            if c == &#39;-&#39;:
                result.append(
                    LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.NOT, i, i))
                symbol_start = i + 1

            if search_string[i:].startswith(&#34;::not&#34;):
                result.append(
                    LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.NOT, i, i + 4))
                symbol_start = i + 5

            if search_string[i:].startswith(&#34;::or&#34;):
                result.append(
                    LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.OR, i, i + 3))
                symbol_start = i + 4

    if not search_string[symbol_start:].isspace():
        result.append(LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:]), symbol_start,
                                  len(search_string) - 1))

    for r in result:
        r.start_index += (r.end_index - r.start_index + 1) - len(search_string[r.start_index:r.end_index + 1].lstrip())
        r.end_index -= (r.end_index - r.start_index + 1) - len(search_string[r.start_index:r.end_index + 1].rstrip())

    result = [r for r in result if r.start_index &lt;= r.end_index]

    if escape_depth != 0:
        return MissingCloseBracket(Brackets.Curly)
    if paren_depth != 0:
        return MissingCloseBracket(Brackets.Parentheses)

    return result


class AST:
    &#34;&#34;&#34;
    Used to store the abstract symbol tree
    &#34;&#34;&#34;

    base_operator: Operator
    tag_values: List[TagValue] = []
    attribute_values: List[AttributeValue] = []

    def __init__(self, base_operator: Operator):
        self.base_operator = base_operator
        self.tag_values = []
        self.attribute_values = []

    def __str__(self) -&gt; str:
        return str(self.base_operator)


#  a parser to turn the symbols from the lexer into an AST, or in this case a tree of operators
def search_string_parser(search_string: Union[str, List[LexerSymbol]]) -&gt; Union[AST, SearchStringParseError]:
    &#34;&#34;&#34;
    Takes in a search string, or array of lexer symbols, converts 
    the string into an array of lexer symbols if needed, then converts 
    that into the abstract symbol tree
    &#34;&#34;&#34;

    if isinstance(search_string, str):
        lex_symbols = search_string_lexer(search_string)
        if isinstance(lex_symbols, SearchStringParseError):
            return lex_symbols
    else:
        lex_symbols = search_string

    # one pass to absorb (, ) or - that are a part of tags

    paren_depth = 0
    embedded_paren = 0

    for i, s in enumerate(lex_symbols):
        if s.symbol_type == LexerSymbolTypes.PAREN_OPEN:
            paren_depth += 1

        if s.symbol_type == LexerSymbolTypes.PAREN_OPEN or search_string[s.start_index] == &#39;-&#39;:
            if i != 0 and lex_symbols[i - 1].symbol_type == LexerSymbolTypes.TAG:
                # &#39;a&#39; &#39;(&#39; -&gt; &#39;a (&#39; or &#39;a&#39; &#39;-&#39; -&gt; &#39;a -&#39;
                lex_symbols[i - 1].end_index = s.end_index
                s.symbol_type = LexerSymbolTypes.IGNORE
                embedded_paren += 1

        if s.symbol_type == LexerSymbolTypes.PAREN_CLOSE:
            if i != len(lex_symbols) - 1 and lex_symbols[i + 1].symbol_type == LexerSymbolTypes.TAG:
                # &#39;)&#39; &#39;a&#39; -&gt; &#39;) a&#39;
                s.end_index = lex_symbols[i + 1].end_index
                s.symbol_type = LexerSymbolTypes.TAG
                lex_symbols[i + 1].symbol_type = LexerSymbolTypes.IGNORE
            elif embedded_paren &gt; 0:
                # &#39;( a&#39; &#39;)&#39; -&gt; &#39;( a )&#39;
                lex_symbols[i-1].end_index = s.end_index
                s.symbol_type = LexerSymbolTypes.IGNORE
                embedded_paren -= 1

            paren_depth -= 1
            if paren_depth &lt; 0:
                return UnexpectedCloseBracket(s.start_index, Brackets.Parentheses)

    # one pass to remove ignore

    lex_symbols = [ls for ls in lex_symbols if ls.symbol_type != LexerSymbolTypes.IGNORE]

    # one pass to combine adj tags

    for i, s in enumerate(lex_symbols):
        if i == 0:
            continue

        if s.symbol_type == LexerSymbolTypes.TAG and lex_symbols[i - 1].symbol_type == LexerSymbolTypes.TAG:
            lex_symbols[i - 1].symbol_type = LexerSymbolTypes.IGNORE
            s.start_index = lex_symbols[i - 1].start_index

    # form ast

    ast = AST(UnitaryOperator(OperatorTypes.Identity, None))
    operator_stack: List[Union[Operator, Value]] = [ast.base_operator]

    escape_depth = 0

    for symbol in lex_symbols:
        if symbol.symbol_type == LexerSymbolTypes.ESCAPE_OPEN:
            escape_depth += 1
        elif symbol.symbol_type == LexerSymbolTypes.ESCAPE_CLOSE:
            escape_depth -= 1

            if escape_depth &lt; 0:
                return UnexpectedCloseBracket(symbol.start_index, Brackets.Curly)
        elif symbol.symbol_type == LexerSymbolTypes.PAREN_OPEN and escape_depth == 0:
            new_operator = UnitaryOperator(OperatorTypes.Identity, None)

            operator_stack[-1].set_right_most(new_operator)
            operator_stack.append(new_operator)
        elif symbol.symbol_type == LexerSymbolTypes.PAREN_CLOSE and escape_depth == 0:
            operator_stack.pop()
            if not operator_stack:
                return UnexpectedCloseBracket(symbol.start_index, Brackets.Parentheses)
        elif symbol.symbol_type == LexerSymbolTypes.NOT:
            new_operator = UnitaryOperator(OperatorTypes.Not, None)

            operator_stack[-1].set_right_most(new_operator)
            operator_stack.append(new_operator)
        elif symbol.symbol_type == LexerSymbolTypes.AND or symbol.symbol_type == LexerSymbolTypes.OR:
            left = operator_stack[-1].get_right_most()
            op_type = OperatorTypes.And if symbol.symbol_type == LexerSymbolTypes.AND else OperatorTypes.Or
            if left is None:
                return UnexpectedOperator(symbol.start_index, op_type)

            if isinstance(left, Operator) and left.op_type == OperatorTypes.Identity:
                left = left.get_left_most()

            new_operator = BinaryOperator(op_type, left, None)
            operator_stack[-1].set_right_most(new_operator)
            operator_stack.append(new_operator)
        elif symbol.symbol_type != LexerSymbolTypes.IGNORE:
            value = Value.parse(search_string[symbol.start_index:symbol.end_index + 1])

            if isinstance(value, TagValue):
                ast.tag_values.append(value)
            elif isinstance(value, AttributeValue):
                ast.attribute_values.append(value)

            operator_stack[-1].set_right_most(value)
            # if len(operator_stack) &gt; 1:
            #     operator_stack.pop()
            #     if len(operator_stack) &gt; 1:
            #         operator_stack.pop()

    return ast


def search_string_to_mongodb_query(mongo: PyMongo, search_string: Union[str, AST], include_hidden: bool = False) -&gt; Union[Dict, List[SearchStringParseError]]:
    &#34;&#34;&#34;
    Takes in a search string, or AST and converts the search string 
    into an AST if neededed, then does all the processing needed to 
    convert that AST into a query that MongoDB understands
    &#34;&#34;&#34;

    if isinstance(search_string, str):
        ast: AST = search_string_parser(search_string)
        if isinstance(ast, SearchStringParseError):
            return [ast]
    else:
        ast: AST = search_string

    # if not include_hidden then add that condition

    if not include_hidden:
        ast.base_operator = BinaryOperator(OperatorTypes.And, ast.base_operator, VisibleItemValue())

    # verify existence of tags/attribs and get their ids

    tag_names: Dict[str, TagValue] = {t.stripped_name: t for t in ast.tag_values}
    attribute_names: Dict[str, AttributeValue] = {a.attribute_name: a for a in ast.attribute_values}

    tags = mongo.db.tags.find({&#34;name&#34;: {&#34;$in&#34;: list(tag_names.keys())}})
    tags = [Tag.from_dict(t) for t in tags]

    for tag in tags:
        tag_names.pop(tag.name).tag_id = tag.id

    if tag_names:
        return [NonexistentTag(t) for t in tag_names.keys()]

    attrib_options = mongo.db.attrib_options.find({&#34;attribute_name&#34;: {&#34;$in&#34;: list(attribute_names.keys())}})
    attrib_options = [AttributeOption.from_dict(t) for t in attrib_options]

    for attrib_option in attrib_options:
        attribute_names.pop(attrib_option.attribute_name).attribute_option_id = attrib_option.id

    if attribute_names:
        return [NonexistentAttribute(t) for t in attribute_names.keys()]

    # now: selectively apply de-morgans law to move all not&#39;s onto atomic values due to limitation in MongoDB search

    to_visit_queue: List[Operator] = [ast.base_operator]

    while to_visit_queue:
        node = to_visit_queue.pop()

        if isinstance(node, UnitaryOperator):
            if node.op_type == OperatorTypes.Identity:
                if isinstance(node.value, Operator):
                    to_visit_queue.append(node.value)
            elif node.op_type == OperatorTypes.Not:
                if isinstance(node.value, UnitaryOperator):
                    if node.value.op_type == OperatorTypes.Identity:
                        # !(a) -&gt; (!a)
                        node.op_type = OperatorTypes.Identity
                        node.value.op_type = OperatorTypes.Not
                    elif node.value.op_type == OperatorTypes.Not:
                        # !!a -&gt; a
                        node.op_type = OperatorTypes.Identity
                        node.value.op_type = OperatorTypes.Identity

                    to_visit_queue.append(node.value)
                elif isinstance(node.value, BinaryOperator):
                    if node.value.op_type == OperatorTypes.And:
                        # !(a &amp;&amp; b) -&gt; (!a || !b)
                        node.op_type = OperatorTypes.Identity
                        node.value.op_type = OperatorTypes.Or

                        node.value.left_value = UnitaryOperator(OperatorTypes.Not, node.value.left_value)
                        node.value.right_value = UnitaryOperator(OperatorTypes.Not, node.value.right_value)
                    elif node.value.op_type == OperatorTypes.Or:
                        # !(a || b) -&gt; (!a &amp;&amp; !b)
                        node.op_type = OperatorTypes.Identity
                        node.value.op_type = OperatorTypes.And

                        node.value.left_value = UnitaryOperator(OperatorTypes.Not, node.value.left_value)
                        node.value.right_value = UnitaryOperator(OperatorTypes.Not, node.value.right_value)

                    to_visit_queue.append(node.value)
                elif isinstance(node.value, Value):
                    # embed the not so it can be processed correctly
                    # !a -&gt; a(not = true)
                    node.op_type = OperatorTypes.Identity
                    node.value.not_value = not node.value.not_value

        elif isinstance(node, BinaryOperator):
            if isinstance(node.left_value, Operator):
                to_visit_queue.append(node.left_value)
            if isinstance(node.right_value, Operator):
                to_visit_queue.append(node.right_value)

    # now form into a search

    return ast.base_operator.to_search_query()

# TODO Basic tests that require by inspection testing, to be replaced by unit tests most likely at some point

# print(&#34;Test ::and -&gt; &#34; + str(LexerSymbolTypes.from_str(&#34;::and&#34;)))
# print(&#34;Test ::or -&gt; &#34; + str(LexerSymbolTypes.from_str(&#34;::or&#34;)))
# print(&#34;Test ::not -&gt; &#34; + str(LexerSymbolTypes.from_str(&#34;::not&#34;)))
# print(&#34;Test , -&gt; &#34; + str(LexerSymbolTypes.from_str(&#34;,&#34;)))
# print(&#34;Test - -&gt; &#34; + str(LexerSymbolTypes.from_str(&#34;-&#34;)))
# print(&#34;Test ( -&gt; &#34; + str(LexerSymbolTypes.from_str(&#34;(&#34;)))
# print(&#34;Test ) -&gt; &#34; + str(LexerSymbolTypes.from_str(&#34;)&#34;)))
# print(&#34;Test { -&gt; &#34; + str(LexerSymbolTypes.from_str(&#34;{&#34;)))
# print(&#34;Test } -&gt; &#34; + str(LexerSymbolTypes.from_str(&#34;}&#34;)))
# print(&#34;Test {_ -&gt; &#34; + str(LexerSymbolTypes.from_str(&#34;{_&#34;)))
# print()
#
#
# def test_lexer(string: str):
#     result = search_string_lexer(string)
#     result_fmt = &#39; &#39;.join(string[i.start_index:i.end_index + 1] for i in result)
#     print(&#34;Testing: &#39;&#34; + string + &#34;&#39;&#34;)
#     print(&#34;\tresult: [&#34; + &#39;, &#39;.join(map(str, result)) + &#34;]&#34;)
#     print(&#34;\tformatted: &#34; + result_fmt)
#
#
# def test_parser_and_lexer(string: str):
#     lexer_result = search_string_lexer(string)
#     lexer_result_fmt = &#39; &#39;.join(string[i.start_index:i.end_index + 1] for i in lexer_result)
#     parser_result = search_string_parser(string)
#
#     print(&#34;Testing: &#39;&#34; + string + &#34;&#39;&#34;)
#     print(&#34;\tlexer result: [&#34; + &#39;, &#39;.join(map(str, lexer_result)) + &#34;]&#34;)
#     print(&#34;\tlexer formatted: &#34; + lexer_result_fmt)
#     print(&#34;\tparser result: &#34; + str(parser_result))
#     print()
#
#
# test_parser_and_lexer(&#34;ak&#34;)
# test_parser_and_lexer(&#34;ak {bk}&#34;)
# test_parser_and_lexer(&#34;ThIs iS A TEst&#34;)
# test_parser_and_lexer(&#34;::not ak&#34;)
# test_parser_and_lexer(&#34;-ak&#34;)
# test_parser_and_lexer(&#34;- ak&#34;)
# test_parser_and_lexer(&#34;ak, bf&#34;)
# test_parser_and_lexer(&#34;ak, bf, cd&#34;)
# test_parser_and_lexer(&#34;ak, (bf, cd)&#34;)
# test_parser_and_lexer(&#34;ak, (bf ::or cd)&#34;)
# test_parser_and_lexer(&#34;ak, (bf ::or cd ::or ::instance::uuid::equals::85781903019)&#34;)
# test_parser_and_lexer(&#34;ak, (bf ::or cd ::or ::instance::UUID::equals::85781903019)&#34;)
# test_parser_and_lexer(&#34;ak, (bf ::or cd ::or ::name::equals::Book&#39;s Book)&#34;)
# test_parser_and_lexer(&#34;ak, (bf ::or cd ::or ::name::Equals::book&#39;s book)&#34;)
# test_parser_and_lexer(&#34;ak, bf, cd ::and (kt ::or ::not y {1} {2})&#34;)
# test_parser_and_lexer(&#34;ak, bf, cd ::and (kt ::or -y {1} {2})&#34;)
# test_parser_and_lexer(&#34;ak, bf, cd ::and (kt ::or ::not {y (1)})&#34;)
# test_parser_and_lexer(&#34;ak, bf, cd ::and (kt ::or -{y (1)})&#34;)
# test_parser_and_lexer(&#34;ak, bf, cd ::and (kt ::or ::not {y (1) {3}})&#34;)
# test_parser_and_lexer(&#34;ak, bf, cd ::and (kt ::or -{y (1) {3}})&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="app.search_parser.search_string_lexer"><code class="name flex">
<span>def <span class="ident">search_string_lexer</span></span>(<span>search_string: str) ‑> Union[List[<a title="app.search_parser.LexerSymbol" href="#app.search_parser.LexerSymbol">LexerSymbol</a>], <a title="app.search_parser.SearchStringParseError" href="#app.search_parser.SearchStringParseError">SearchStringParseError</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in a search string and converts it intl an array of lexer symbols</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_string_lexer(search_string: str) -&gt; Union[List[LexerSymbol], SearchStringParseError]:
    &#34;&#34;&#34;
    Takes in a search string and converts it intl an array of lexer symbols
    &#34;&#34;&#34;

    result = []

    escape_depth = 0
    paren_depth = 0
    symbol_start = 0
    skipped = False

    for i, c in enumerate(search_string):

        if c == &#39;{&#39;:
            escape_depth += 1

            if escape_depth == 1:
                if search_string[symbol_start:i].isspace():
                    # result.append(
                    #     LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))

                    result.append(LexerSymbol(LexerSymbolTypes.ESCAPE_OPEN, i, i))
                    symbol_start = i + 1

                    skipped = False
                else:
                    skipped = True

        elif c == &#39;}&#39;:
            escape_depth -= 1

            if escape_depth == 0 and not skipped:
                result.append(LexerSymbol(LexerSymbolTypes.TAG, symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.ESCAPE_CLOSE, i, i))

                symbol_start = i + 1
            elif escape_depth &lt; 0:
                return UnexpectedCloseBracket(i, Brackets.Curly)
        elif escape_depth == 0:
            if c == &#39;(&#39; or c == &#39;)&#39;:
                if c == &#39;(&#39;:
                    paren_depth += 1
                else:
                    paren_depth -= 1

                    if paren_depth &lt; 0:
                        return UnexpectedCloseBracket(i, Brackets.Parentheses)

                result.append(
                    LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.from_str(c), i, i))
                symbol_start = i + 1

            if c == &#39;,&#39;:
                result.append(
                    LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.AND, i, i))
                symbol_start = i + 1

            if search_string[i:].startswith(&#34;::and&#34;):
                result.append(
                    LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.AND, i, i + 4))
                symbol_start = i + 5

            if c == &#39;-&#39;:
                result.append(
                    LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.NOT, i, i))
                symbol_start = i + 1

            if search_string[i:].startswith(&#34;::not&#34;):
                result.append(
                    LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.NOT, i, i + 4))
                symbol_start = i + 5

            if search_string[i:].startswith(&#34;::or&#34;):
                result.append(
                    LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:i]), symbol_start, i - 1))
                result.append(LexerSymbol(LexerSymbolTypes.OR, i, i + 3))
                symbol_start = i + 4

    if not search_string[symbol_start:].isspace():
        result.append(LexerSymbol(LexerSymbolTypes.from_str(search_string[symbol_start:]), symbol_start,
                                  len(search_string) - 1))

    for r in result:
        r.start_index += (r.end_index - r.start_index + 1) - len(search_string[r.start_index:r.end_index + 1].lstrip())
        r.end_index -= (r.end_index - r.start_index + 1) - len(search_string[r.start_index:r.end_index + 1].rstrip())

    result = [r for r in result if r.start_index &lt;= r.end_index]

    if escape_depth != 0:
        return MissingCloseBracket(Brackets.Curly)
    if paren_depth != 0:
        return MissingCloseBracket(Brackets.Parentheses)

    return result</code></pre>
</details>
</dd>
<dt id="app.search_parser.search_string_parser"><code class="name flex">
<span>def <span class="ident">search_string_parser</span></span>(<span>search_string: Union[str, List[<a title="app.search_parser.LexerSymbol" href="#app.search_parser.LexerSymbol">LexerSymbol</a>]]) ‑> Union[<a title="app.search_parser.AST" href="#app.search_parser.AST">AST</a>, <a title="app.search_parser.SearchStringParseError" href="#app.search_parser.SearchStringParseError">SearchStringParseError</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in a search string, or array of lexer symbols, converts
the string into an array of lexer symbols if needed, then converts
that into the abstract symbol tree</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_string_parser(search_string: Union[str, List[LexerSymbol]]) -&gt; Union[AST, SearchStringParseError]:
    &#34;&#34;&#34;
    Takes in a search string, or array of lexer symbols, converts 
    the string into an array of lexer symbols if needed, then converts 
    that into the abstract symbol tree
    &#34;&#34;&#34;

    if isinstance(search_string, str):
        lex_symbols = search_string_lexer(search_string)
        if isinstance(lex_symbols, SearchStringParseError):
            return lex_symbols
    else:
        lex_symbols = search_string

    # one pass to absorb (, ) or - that are a part of tags

    paren_depth = 0
    embedded_paren = 0

    for i, s in enumerate(lex_symbols):
        if s.symbol_type == LexerSymbolTypes.PAREN_OPEN:
            paren_depth += 1

        if s.symbol_type == LexerSymbolTypes.PAREN_OPEN or search_string[s.start_index] == &#39;-&#39;:
            if i != 0 and lex_symbols[i - 1].symbol_type == LexerSymbolTypes.TAG:
                # &#39;a&#39; &#39;(&#39; -&gt; &#39;a (&#39; or &#39;a&#39; &#39;-&#39; -&gt; &#39;a -&#39;
                lex_symbols[i - 1].end_index = s.end_index
                s.symbol_type = LexerSymbolTypes.IGNORE
                embedded_paren += 1

        if s.symbol_type == LexerSymbolTypes.PAREN_CLOSE:
            if i != len(lex_symbols) - 1 and lex_symbols[i + 1].symbol_type == LexerSymbolTypes.TAG:
                # &#39;)&#39; &#39;a&#39; -&gt; &#39;) a&#39;
                s.end_index = lex_symbols[i + 1].end_index
                s.symbol_type = LexerSymbolTypes.TAG
                lex_symbols[i + 1].symbol_type = LexerSymbolTypes.IGNORE
            elif embedded_paren &gt; 0:
                # &#39;( a&#39; &#39;)&#39; -&gt; &#39;( a )&#39;
                lex_symbols[i-1].end_index = s.end_index
                s.symbol_type = LexerSymbolTypes.IGNORE
                embedded_paren -= 1

            paren_depth -= 1
            if paren_depth &lt; 0:
                return UnexpectedCloseBracket(s.start_index, Brackets.Parentheses)

    # one pass to remove ignore

    lex_symbols = [ls for ls in lex_symbols if ls.symbol_type != LexerSymbolTypes.IGNORE]

    # one pass to combine adj tags

    for i, s in enumerate(lex_symbols):
        if i == 0:
            continue

        if s.symbol_type == LexerSymbolTypes.TAG and lex_symbols[i - 1].symbol_type == LexerSymbolTypes.TAG:
            lex_symbols[i - 1].symbol_type = LexerSymbolTypes.IGNORE
            s.start_index = lex_symbols[i - 1].start_index

    # form ast

    ast = AST(UnitaryOperator(OperatorTypes.Identity, None))
    operator_stack: List[Union[Operator, Value]] = [ast.base_operator]

    escape_depth = 0

    for symbol in lex_symbols:
        if symbol.symbol_type == LexerSymbolTypes.ESCAPE_OPEN:
            escape_depth += 1
        elif symbol.symbol_type == LexerSymbolTypes.ESCAPE_CLOSE:
            escape_depth -= 1

            if escape_depth &lt; 0:
                return UnexpectedCloseBracket(symbol.start_index, Brackets.Curly)
        elif symbol.symbol_type == LexerSymbolTypes.PAREN_OPEN and escape_depth == 0:
            new_operator = UnitaryOperator(OperatorTypes.Identity, None)

            operator_stack[-1].set_right_most(new_operator)
            operator_stack.append(new_operator)
        elif symbol.symbol_type == LexerSymbolTypes.PAREN_CLOSE and escape_depth == 0:
            operator_stack.pop()
            if not operator_stack:
                return UnexpectedCloseBracket(symbol.start_index, Brackets.Parentheses)
        elif symbol.symbol_type == LexerSymbolTypes.NOT:
            new_operator = UnitaryOperator(OperatorTypes.Not, None)

            operator_stack[-1].set_right_most(new_operator)
            operator_stack.append(new_operator)
        elif symbol.symbol_type == LexerSymbolTypes.AND or symbol.symbol_type == LexerSymbolTypes.OR:
            left = operator_stack[-1].get_right_most()
            op_type = OperatorTypes.And if symbol.symbol_type == LexerSymbolTypes.AND else OperatorTypes.Or
            if left is None:
                return UnexpectedOperator(symbol.start_index, op_type)

            if isinstance(left, Operator) and left.op_type == OperatorTypes.Identity:
                left = left.get_left_most()

            new_operator = BinaryOperator(op_type, left, None)
            operator_stack[-1].set_right_most(new_operator)
            operator_stack.append(new_operator)
        elif symbol.symbol_type != LexerSymbolTypes.IGNORE:
            value = Value.parse(search_string[symbol.start_index:symbol.end_index + 1])

            if isinstance(value, TagValue):
                ast.tag_values.append(value)
            elif isinstance(value, AttributeValue):
                ast.attribute_values.append(value)

            operator_stack[-1].set_right_most(value)
            # if len(operator_stack) &gt; 1:
            #     operator_stack.pop()
            #     if len(operator_stack) &gt; 1:
            #         operator_stack.pop()

    return ast</code></pre>
</details>
</dd>
<dt id="app.search_parser.search_string_to_mongodb_query"><code class="name flex">
<span>def <span class="ident">search_string_to_mongodb_query</span></span>(<span>mongo: flask_pymongo.PyMongo, search_string: Union[str, <a title="app.search_parser.AST" href="#app.search_parser.AST">AST</a>], include_hidden: bool = False) ‑> Union[Dict, List[<a title="app.search_parser.SearchStringParseError" href="#app.search_parser.SearchStringParseError">SearchStringParseError</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in a search string, or AST and converts the search string
into an AST if neededed, then does all the processing needed to
convert that AST into a query that MongoDB understands</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_string_to_mongodb_query(mongo: PyMongo, search_string: Union[str, AST], include_hidden: bool = False) -&gt; Union[Dict, List[SearchStringParseError]]:
    &#34;&#34;&#34;
    Takes in a search string, or AST and converts the search string 
    into an AST if neededed, then does all the processing needed to 
    convert that AST into a query that MongoDB understands
    &#34;&#34;&#34;

    if isinstance(search_string, str):
        ast: AST = search_string_parser(search_string)
        if isinstance(ast, SearchStringParseError):
            return [ast]
    else:
        ast: AST = search_string

    # if not include_hidden then add that condition

    if not include_hidden:
        ast.base_operator = BinaryOperator(OperatorTypes.And, ast.base_operator, VisibleItemValue())

    # verify existence of tags/attribs and get their ids

    tag_names: Dict[str, TagValue] = {t.stripped_name: t for t in ast.tag_values}
    attribute_names: Dict[str, AttributeValue] = {a.attribute_name: a for a in ast.attribute_values}

    tags = mongo.db.tags.find({&#34;name&#34;: {&#34;$in&#34;: list(tag_names.keys())}})
    tags = [Tag.from_dict(t) for t in tags]

    for tag in tags:
        tag_names.pop(tag.name).tag_id = tag.id

    if tag_names:
        return [NonexistentTag(t) for t in tag_names.keys()]

    attrib_options = mongo.db.attrib_options.find({&#34;attribute_name&#34;: {&#34;$in&#34;: list(attribute_names.keys())}})
    attrib_options = [AttributeOption.from_dict(t) for t in attrib_options]

    for attrib_option in attrib_options:
        attribute_names.pop(attrib_option.attribute_name).attribute_option_id = attrib_option.id

    if attribute_names:
        return [NonexistentAttribute(t) for t in attribute_names.keys()]

    # now: selectively apply de-morgans law to move all not&#39;s onto atomic values due to limitation in MongoDB search

    to_visit_queue: List[Operator] = [ast.base_operator]

    while to_visit_queue:
        node = to_visit_queue.pop()

        if isinstance(node, UnitaryOperator):
            if node.op_type == OperatorTypes.Identity:
                if isinstance(node.value, Operator):
                    to_visit_queue.append(node.value)
            elif node.op_type == OperatorTypes.Not:
                if isinstance(node.value, UnitaryOperator):
                    if node.value.op_type == OperatorTypes.Identity:
                        # !(a) -&gt; (!a)
                        node.op_type = OperatorTypes.Identity
                        node.value.op_type = OperatorTypes.Not
                    elif node.value.op_type == OperatorTypes.Not:
                        # !!a -&gt; a
                        node.op_type = OperatorTypes.Identity
                        node.value.op_type = OperatorTypes.Identity

                    to_visit_queue.append(node.value)
                elif isinstance(node.value, BinaryOperator):
                    if node.value.op_type == OperatorTypes.And:
                        # !(a &amp;&amp; b) -&gt; (!a || !b)
                        node.op_type = OperatorTypes.Identity
                        node.value.op_type = OperatorTypes.Or

                        node.value.left_value = UnitaryOperator(OperatorTypes.Not, node.value.left_value)
                        node.value.right_value = UnitaryOperator(OperatorTypes.Not, node.value.right_value)
                    elif node.value.op_type == OperatorTypes.Or:
                        # !(a || b) -&gt; (!a &amp;&amp; !b)
                        node.op_type = OperatorTypes.Identity
                        node.value.op_type = OperatorTypes.And

                        node.value.left_value = UnitaryOperator(OperatorTypes.Not, node.value.left_value)
                        node.value.right_value = UnitaryOperator(OperatorTypes.Not, node.value.right_value)

                    to_visit_queue.append(node.value)
                elif isinstance(node.value, Value):
                    # embed the not so it can be processed correctly
                    # !a -&gt; a(not = true)
                    node.op_type = OperatorTypes.Identity
                    node.value.not_value = not node.value.not_value

        elif isinstance(node, BinaryOperator):
            if isinstance(node.left_value, Operator):
                to_visit_queue.append(node.left_value)
            if isinstance(node.right_value, Operator):
                to_visit_queue.append(node.right_value)

    # now form into a search

    return ast.base_operator.to_search_query()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="app.search_parser.AST"><code class="flex name class">
<span>class <span class="ident">AST</span></span>
<span>(</span><span>base_operator: <a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Used to store the abstract symbol tree</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AST:
    &#34;&#34;&#34;
    Used to store the abstract symbol tree
    &#34;&#34;&#34;

    base_operator: Operator
    tag_values: List[TagValue] = []
    attribute_values: List[AttributeValue] = []

    def __init__(self, base_operator: Operator):
        self.base_operator = base_operator
        self.tag_values = []
        self.attribute_values = []

    def __str__(self) -&gt; str:
        return str(self.base_operator)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.AST.attribute_values"><code class="name">var <span class="ident">attribute_values</span> : List[<a title="app.search_parser.AttributeValue" href="#app.search_parser.AttributeValue">AttributeValue</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.AST.base_operator"><code class="name">var <span class="ident">base_operator</span> : <a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.AST.tag_values"><code class="name">var <span class="ident">tag_values</span> : List[<a title="app.search_parser.TagValue" href="#app.search_parser.TagValue">TagValue</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="app.search_parser.AttributeValue"><code class="flex name class">
<span>class <span class="ident">AttributeValue</span></span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of Value, for the specific case where we are looking
for an attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AttributeValue(Value):
    &#34;&#34;&#34;
    A subclass of Value, for the specific case where we are looking 
    for an attribute
    &#34;&#34;&#34;

    attribute_name: str
    attribute_option_id: Optional[ObjectId] = None

    def __str__(self) -&gt; str:
        return super().__str__()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="app.search_parser.CheckInstanceAttributeValue" href="#app.search_parser.CheckInstanceAttributeValue">CheckInstanceAttributeValue</a></li>
<li><a title="app.search_parser.CheckItemAttributeValue" href="#app.search_parser.CheckItemAttributeValue">CheckItemAttributeValue</a></li>
<li><a title="app.search_parser.HasInstanceAttributeValue" href="#app.search_parser.HasInstanceAttributeValue">HasInstanceAttributeValue</a></li>
<li><a title="app.search_parser.HasItemAttributeValue" href="#app.search_parser.HasItemAttributeValue">HasItemAttributeValue</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.AttributeValue.attribute_name"><code class="name">var <span class="ident">attribute_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.AttributeValue.attribute_option_id"><code class="name">var <span class="ident">attribute_option_id</span> : Union[bson.objectid.ObjectId, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a></b></code>:
<ul class="hlist">
<li><code><a title="app.search_parser.Value.parse" href="#app.search_parser.Value.parse">parse</a></code></li>
<li><code><a title="app.search_parser.Value.to_search_query" href="#app.search_parser.Value.to_search_query">to_search_query</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="app.search_parser.BinaryOperator"><code class="flex name class">
<span>class <span class="ident">BinaryOperator</span></span>
<span>(</span><span>op_type: <a title="app.search_parser.OperatorTypes" href="#app.search_parser.OperatorTypes">OperatorTypes</a>, left_value: Union[<a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a>, <a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a>], right_value: Union[<a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a>, <a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of Operator for the specific instance of an operator
that takes in two values, such as 'and' or 'or'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinaryOperator(Operator):
    &#34;&#34;&#34;
    A subclass of Operator for the specific instance of an operator 
    that takes in two values, such as &#39;and&#39; or &#39;or&#39;
    &#34;&#34;&#34;

    left_value: Union[Operator, Value]
    right_value: Union[Operator, Value]

    def __init__(self, op_type: OperatorTypes, left_value: Union[Operator, Value], right_value: Union[Operator, Value]):
        super().__init__(op_type)

        self.left_value = left_value
        self.right_value = right_value

    def get_left_most(self) -&gt; Union[Operator, Value]:
        &#34;&#34;&#34;
        Get the left most child of this node
        &#34;&#34;&#34;
        return self.left_value

    def get_right_most(self) -&gt; Union[Operator, Value]:
        &#34;&#34;&#34;
        Get the right most child of this node
        &#34;&#34;&#34;
        return self.right_value

    def set_left_most(self, value: Union[Operator, Value]):
        &#34;&#34;&#34;
        Set the left most child of this node
        &#34;&#34;&#34;
        self.left_value = value

    def set_right_most(self, value: Union[Operator, Value]):
        &#34;&#34;&#34;
        Set the right most child of this node
        &#34;&#34;&#34;
        self.right_value = value

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Convert back to string for debugging
        &#34;&#34;&#34;
        if self.op_type == OperatorTypes.And:
            return &#34;(&#34; + str(self.left_value) + &#34; ::and &#34; + str(self.right_value) + &#34;)&#34;
        else:
            return &#34;(&#34; + str(self.left_value) + &#34; ::or &#34; + str(self.right_value) + &#34;)&#34;

    def to_search_query(self) -&gt; Dict:
        &#34;&#34;&#34;
        Recursively convert this node and it&#39;s children to a MongoDB query
        &#34;&#34;&#34;
        if self.op_type == OperatorTypes.And:
            return {&#34;$and&#34;: [self.left_value.to_search_query(), self.right_value.to_search_query()]}
        else:
            return {&#34;$or&#34;: [self.left_value.to_search_query(), self.right_value.to_search_query()]}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.BinaryOperator.left_value"><code class="name">var <span class="ident">left_value</span> : Union[<a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a>, <a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.BinaryOperator.right_value"><code class="name">var <span class="ident">right_value</span> : Union[<a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a>, <a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a></b></code>:
<ul class="hlist">
<li><code><a title="app.search_parser.Operator.get_left_most" href="#app.search_parser.Operator.get_left_most">get_left_most</a></code></li>
<li><code><a title="app.search_parser.Operator.get_right_most" href="#app.search_parser.Operator.get_right_most">get_right_most</a></code></li>
<li><code><a title="app.search_parser.Operator.set_left_most" href="#app.search_parser.Operator.set_left_most">set_left_most</a></code></li>
<li><code><a title="app.search_parser.Operator.set_right_most" href="#app.search_parser.Operator.set_right_most">set_right_most</a></code></li>
<li><code><a title="app.search_parser.Operator.to_search_query" href="#app.search_parser.Operator.to_search_query">to_search_query</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="app.search_parser.Brackets"><code class="flex name class">
<span>class <span class="ident">Brackets</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enum class used to enumerate the two types of parthenthsis
and to be able to just lookup their character representations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Brackets(Enum):
    &#34;&#34;&#34;
    An enum class used to enumerate the two types of parthenthsis 
    and to be able to just lookup their character representations
    &#34;&#34;&#34;

    Parentheses = [&#34;Parentheses&#34;, &#39;(&#39;, &#39;)&#39;]
    Curly = [&#34;Curly&#34;, &#39;{&#39;, &#39;}&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.Brackets.Curly"><code class="name">var <span class="ident">Curly</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.Brackets.Parentheses"><code class="name">var <span class="ident">Parentheses</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="app.search_parser.CheckInstanceAttributeValue"><code class="flex name class">
<span>class <span class="ident">CheckInstanceAttributeValue</span></span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of AttributeValue, for when checking for a specific
value of an instance's attribute, like 'name::equals::Bob' or
'name::contains::Bob'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CheckInstanceAttributeValue(AttributeValue):
    &#34;&#34;&#34;
    A subclass of AttributeValue, for when checking for a specific 
    value of an instance&#39;s attribute, like &#39;name::equals::Bob&#39; or 
    &#39;name::contains::Bob&#39;
    &#34;&#34;&#34;

    check_mode: CheckMode
    value: str

    def __str__(self) -&gt; str:
        return &#34;CheckInstanceAttribute: &#39;&#34; + self.attribute_name + &#34;&#39;&#34; + &#34; | &#34; + str(
            self.check_mode) + &#34; | &#39;&#34; + self.value + &#34;&#39;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.AttributeValue" href="#app.search_parser.AttributeValue">AttributeValue</a></li>
<li><a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.CheckInstanceAttributeValue.check_mode"><code class="name">var <span class="ident">check_mode</span> : <a title="app.search_parser.CheckMode" href="#app.search_parser.CheckMode">CheckMode</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.CheckInstanceAttributeValue.value"><code class="name">var <span class="ident">value</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="app.search_parser.AttributeValue" href="#app.search_parser.AttributeValue">AttributeValue</a></b></code>:
<ul class="hlist">
<li><code><a title="app.search_parser.AttributeValue.parse" href="#app.search_parser.Value.parse">parse</a></code></li>
<li><code><a title="app.search_parser.AttributeValue.to_search_query" href="#app.search_parser.Value.to_search_query">to_search_query</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="app.search_parser.CheckItemAttributeValue"><code class="flex name class">
<span>class <span class="ident">CheckItemAttributeValue</span></span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of AttributeValue, for when checking for a specific
value of an item's attribute, like 'name::equals::Bob' or 'name::contains::Bob'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CheckItemAttributeValue(AttributeValue):
    &#34;&#34;&#34;
    A subclass of AttributeValue, for when checking for a specific 
    value of an item&#39;s attribute, like &#39;name::equals::Bob&#39; or &#39;name::contains::Bob&#39;
    &#34;&#34;&#34;

    check_mode: CheckMode
    value: str

    def __str__(self) -&gt; str:
        return &#34;CheckItemAttribute: &#39;&#34; + self.attribute_name + &#34;&#39;&#34; + &#34; | &#34; + str(
            self.check_mode) + &#34; | &#39;&#34; + self.value + &#34;&#39;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.AttributeValue" href="#app.search_parser.AttributeValue">AttributeValue</a></li>
<li><a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.CheckItemAttributeValue.check_mode"><code class="name">var <span class="ident">check_mode</span> : <a title="app.search_parser.CheckMode" href="#app.search_parser.CheckMode">CheckMode</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.CheckItemAttributeValue.value"><code class="name">var <span class="ident">value</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="app.search_parser.AttributeValue" href="#app.search_parser.AttributeValue">AttributeValue</a></b></code>:
<ul class="hlist">
<li><code><a title="app.search_parser.AttributeValue.parse" href="#app.search_parser.Value.parse">parse</a></code></li>
<li><code><a title="app.search_parser.AttributeValue.to_search_query" href="#app.search_parser.Value.to_search_query">to_search_query</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="app.search_parser.CheckMode"><code class="flex name class">
<span>class <span class="ident">CheckMode</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>For the value checks below, enumerates whether it is 'equals' or 'contains'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CheckMode(Enum):
    &#34;&#34;&#34;
    For the value checks below, enumerates whether it is &#39;equals&#39; or &#39;contains&#39;
    &#34;&#34;&#34;

    Equals = 0,
    Contains = 1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.CheckMode.Contains"><code class="name">var <span class="ident">Contains</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.CheckMode.Equals"><code class="name">var <span class="ident">Equals</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="app.search_parser.HasInstanceAttributeValue"><code class="flex name class">
<span>class <span class="ident">HasInstanceAttributeValue</span></span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of AttributeValue, for when we are looking for an instance
to have an attribute, like: 'instance::has::name'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HasInstanceAttributeValue(AttributeValue):
    &#34;&#34;&#34;
    A subclass of AttributeValue, for when we are looking for an instance 
    to have an attribute, like: &#39;instance::has::name&#39;
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;HasInstanceAttribute: &#39;&#34; + self.attribute_name + &#34;&#39;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.AttributeValue" href="#app.search_parser.AttributeValue">AttributeValue</a></li>
<li><a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.HasInstanceAttributeValue.attribute_name"><code class="name">var <span class="ident">attribute_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.HasInstanceAttributeValue.attribute_option_id"><code class="name">var <span class="ident">attribute_option_id</span> : Union[bson.objectid.ObjectId, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="app.search_parser.AttributeValue" href="#app.search_parser.AttributeValue">AttributeValue</a></b></code>:
<ul class="hlist">
<li><code><a title="app.search_parser.AttributeValue.parse" href="#app.search_parser.Value.parse">parse</a></code></li>
<li><code><a title="app.search_parser.AttributeValue.to_search_query" href="#app.search_parser.Value.to_search_query">to_search_query</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="app.search_parser.HasItemAttributeValue"><code class="flex name class">
<span>class <span class="ident">HasItemAttributeValue</span></span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of AttributeValue, for when we are looking for an item
to have an attribute, like: 'has::name'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HasItemAttributeValue(AttributeValue):
    &#34;&#34;&#34;
    A subclass of AttributeValue, for when we are looking for an item 
    to have an attribute, like: &#39;has::name&#39;
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;HasItemAttribute: &#39;&#34; + self.attribute_name + &#34;&#39;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.AttributeValue" href="#app.search_parser.AttributeValue">AttributeValue</a></li>
<li><a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.HasItemAttributeValue.attribute_name"><code class="name">var <span class="ident">attribute_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.HasItemAttributeValue.attribute_option_id"><code class="name">var <span class="ident">attribute_option_id</span> : Union[bson.objectid.ObjectId, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="app.search_parser.AttributeValue" href="#app.search_parser.AttributeValue">AttributeValue</a></b></code>:
<ul class="hlist">
<li><code><a title="app.search_parser.AttributeValue.parse" href="#app.search_parser.Value.parse">parse</a></code></li>
<li><code><a title="app.search_parser.AttributeValue.to_search_query" href="#app.search_parser.Value.to_search_query">to_search_query</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="app.search_parser.InstanceTagValue"><code class="flex name class">
<span>class <span class="ident">InstanceTagValue</span></span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of TagValue, for the specific case where the tag is
for a tag attached to an instance, like 'instance::a'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InstanceTagValue(TagValue):
    &#34;&#34;&#34;
    A subclass of TagValue, for the specific case where the tag is 
    for a tag attached to an instance, like &#39;instance::a&#39;
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;InstanceTag: &#39;&#34; + self.stripped_name + &#34;&#39;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.TagValue" href="#app.search_parser.TagValue">TagValue</a></li>
<li><a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.InstanceTagValue.stripped_name"><code class="name">var <span class="ident">stripped_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.InstanceTagValue.tag_id"><code class="name">var <span class="ident">tag_id</span> : Union[bson.objectid.ObjectId, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="app.search_parser.TagValue" href="#app.search_parser.TagValue">TagValue</a></b></code>:
<ul class="hlist">
<li><code><a title="app.search_parser.TagValue.parse" href="#app.search_parser.Value.parse">parse</a></code></li>
<li><code><a title="app.search_parser.TagValue.to_search_query" href="#app.search_parser.Value.to_search_query">to_search_query</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="app.search_parser.ItemTagValue"><code class="flex name class">
<span>class <span class="ident">ItemTagValue</span></span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of TagValue, for the specific case where the tag is
for a tag attached to an item, like 'a'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ItemTagValue(TagValue):
    &#34;&#34;&#34;
    A subclass of TagValue, for the specific case where the tag is 
    for a tag attached to an item, like &#39;a&#39;  
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Tag: &#39;&#34; + self.stripped_name + &#34;&#39;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.TagValue" href="#app.search_parser.TagValue">TagValue</a></li>
<li><a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.ItemTagValue.stripped_name"><code class="name">var <span class="ident">stripped_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.ItemTagValue.tag_id"><code class="name">var <span class="ident">tag_id</span> : Union[bson.objectid.ObjectId, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="app.search_parser.TagValue" href="#app.search_parser.TagValue">TagValue</a></b></code>:
<ul class="hlist">
<li><code><a title="app.search_parser.TagValue.parse" href="#app.search_parser.Value.parse">parse</a></code></li>
<li><code><a title="app.search_parser.TagValue.to_search_query" href="#app.search_parser.Value.to_search_query">to_search_query</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="app.search_parser.LexerSymbol"><code class="flex name class">
<span>class <span class="ident">LexerSymbol</span></span>
<span>(</span><span>symbol_type: <a title="app.search_parser.LexerSymbolTypes" href="#app.search_parser.LexerSymbolTypes">LexerSymbolTypes</a>, start_index: int, end_index: int)</span>
</code></dt>
<dd>
<div class="desc"><p>A class used by the lexer to store the symbols it extracts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LexerSymbol:
    &#34;&#34;&#34;
    A class used by the lexer to store the symbols it extracts
    &#34;&#34;&#34;

    symbol_type: LexerSymbolTypes
    start_index: int
    end_index: int

    def __init__(self, symbol_type: LexerSymbolTypes, start_index: int, end_index: int):
        self.symbol_type = symbol_type
        self.start_index = start_index
        self.end_index = end_index

    def __str__(self) -&gt; str:
        if isinstance(self.symbol_type.value, list):
            symbol_str = self.symbol_type.value[0]
        elif self.symbol_type.value is not None:
            symbol_str = self.symbol_type.value
        else:
            symbol_str = &#34;::TAG&#34;

        return &#34;[&#34; + str(self.start_index) + &#34;, &#34; + str(self.end_index) + &#34;]&#34; + symbol_str</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.LexerSymbol.end_index"><code class="name">var <span class="ident">end_index</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.LexerSymbol.start_index"><code class="name">var <span class="ident">start_index</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.LexerSymbol.symbol_type"><code class="name">var <span class="ident">symbol_type</span> : <a title="app.search_parser.LexerSymbolTypes" href="#app.search_parser.LexerSymbolTypes">LexerSymbolTypes</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="app.search_parser.LexerSymbolTypes"><code class="flex name class">
<span>class <span class="ident">LexerSymbolTypes</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enum used to represent all the different symbols that the lexer
must proccess, along with their character representations, and array
of string represents an alias</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LexerSymbolTypes(Enum):
    &#34;&#34;&#34;
    An enum used to represent all the different symbols that the lexer 
    must proccess, along with their character representations, and array
    of string represents an alias
    &#34;&#34;&#34;

    # Operators
    AND = [&#34;::and&#34;, &#39;,&#39;]
    OR = &#34;::or&#34;
    NOT = [&#34;::not&#34;, &#39;-&#39;]
    # Brackets
    PAREN_OPEN = &#34;(&#34;
    PAREN_CLOSE = &#34;)&#34;
    ESCAPE_OPEN = &#34;{&#34;
    ESCAPE_CLOSE = &#34;}&#34;
    # Tags
    TAG = None
    IGNORE = &#34;&#34;

    @staticmethod
    def from_str(value: str) -&gt; &#39;LexerSymbolTypes&#39;:
        &#34;&#34;&#34;
        Convert a string into a lexer symbol type based on theirt string representations
        &#34;&#34;&#34;

        for option in LexerSymbolTypes:
            if isinstance(option.value, list):
                for o in option.value:
                    if o == value:
                        return option
            else:
                if option.value == value:
                    return option
        return LexerSymbolTypes.TAG</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.LexerSymbolTypes.AND"><code class="name">var <span class="ident">AND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.LexerSymbolTypes.ESCAPE_CLOSE"><code class="name">var <span class="ident">ESCAPE_CLOSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.LexerSymbolTypes.ESCAPE_OPEN"><code class="name">var <span class="ident">ESCAPE_OPEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.LexerSymbolTypes.IGNORE"><code class="name">var <span class="ident">IGNORE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.LexerSymbolTypes.NOT"><code class="name">var <span class="ident">NOT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.LexerSymbolTypes.OR"><code class="name">var <span class="ident">OR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.LexerSymbolTypes.PAREN_CLOSE"><code class="name">var <span class="ident">PAREN_CLOSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.LexerSymbolTypes.PAREN_OPEN"><code class="name">var <span class="ident">PAREN_OPEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.LexerSymbolTypes.TAG"><code class="name">var <span class="ident">TAG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="app.search_parser.LexerSymbolTypes.from_str"><code class="name flex">
<span>def <span class="ident">from_str</span></span>(<span>value: str) ‑> <a title="app.search_parser.LexerSymbolTypes" href="#app.search_parser.LexerSymbolTypes">LexerSymbolTypes</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert a string into a lexer symbol type based on theirt string representations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_str(value: str) -&gt; &#39;LexerSymbolTypes&#39;:
    &#34;&#34;&#34;
    Convert a string into a lexer symbol type based on theirt string representations
    &#34;&#34;&#34;

    for option in LexerSymbolTypes:
        if isinstance(option.value, list):
            for o in option.value:
                if o == value:
                    return option
        else:
            if option.value == value:
                return option
    return LexerSymbolTypes.TAG</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="app.search_parser.MissingCloseBracket"><code class="flex name class">
<span>class <span class="ident">MissingCloseBracket</span></span>
<span>(</span><span>bracket: <a title="app.search_parser.Brackets" href="#app.search_parser.Brackets">Brackets</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of SearchStringParseError, for the specific instance
where a close baracket (either } or )) was missing, where is
was required such as '(a :: and b'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MissingCloseBracket(SearchStringParseError):
    &#34;&#34;&#34;
    A subclass of SearchStringParseError, for the specific instance 
    where a close baracket (either } or )) was missing, where is 
    was required such as &#39;(a :: and b&#39;
    &#34;&#34;&#34;

    def __init__(self, bracket: Brackets):
        self.bracket = bracket

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Missing a closing &#39;&#34; + self.bracket.value[2] + &#34;&#39;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.SearchStringParseError" href="#app.search_parser.SearchStringParseError">SearchStringParseError</a></li>
</ul>
</dd>
<dt id="app.search_parser.NonexistentAttribute"><code class="flex name class">
<span>class <span class="ident">NonexistentAttribute</span></span>
<span>(</span><span>string: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of SearchStringParseError, for the specific instance
where an attribute does not exisit in the DBA subclass of
SearchStringParseError, for the specific instance where an attribute
does not exisit in the DB</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NonexistentAttribute(SearchStringParseError):
    &#34;&#34;&#34;
    A subclass of SearchStringParseError, for the specific instance 
    where an attribute does not exisit in the DBA subclass of 
    SearchStringParseError, for the specific instance where an attribute 
    does not exisit in the DB
    &#34;&#34;&#34;

    def __init__(self, string: str):
        self.string = string

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Nonexistent attribute: [&#34; + self.string + &#34;]&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.SearchStringParseError" href="#app.search_parser.SearchStringParseError">SearchStringParseError</a></li>
</ul>
</dd>
<dt id="app.search_parser.NonexistentTag"><code class="flex name class">
<span>class <span class="ident">NonexistentTag</span></span>
<span>(</span><span>string: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of SearchStringParseError, for the specific instance
where a tag does not exisit in the DB</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NonexistentTag(SearchStringParseError):
    &#34;&#34;&#34;
    A subclass of SearchStringParseError, for the specific instance 
    where a tag does not exisit in the DB
    &#34;&#34;&#34;

    def __init__(self, string: str):
        self.string = string

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Nonexistent tag: [&#34; + self.string + &#34;]&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.SearchStringParseError" href="#app.search_parser.SearchStringParseError">SearchStringParseError</a></li>
</ul>
</dd>
<dt id="app.search_parser.Operator"><code class="flex name class">
<span>class <span class="ident">Operator</span></span>
<span>(</span><span>op_type: <a title="app.search_parser.OperatorTypes" href="#app.search_parser.OperatorTypes">OperatorTypes</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A general base class for the two types of operator (unitary, binary)
as a node in a abstact symbol tree of operators and values on the leafs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Operator(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;
    A general base class for the two types of operator (unitary, binary) 
    as a node in a abstact symbol tree of operators and values on the leafs
    &#34;&#34;&#34;

    op_type: OperatorTypes = None

    def __init__(self, op_type: OperatorTypes):
        self.op_type = op_type

    @abc.abstractmethod
    def get_left_most(self) -&gt; Union[&#39;Operator&#39;, Value]:
        &#34;&#34;&#34;
        Get the left most child of this node
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def get_right_most(self) -&gt; Union[&#39;Operator&#39;, Value]:
        &#34;&#34;&#34;
        Get the right most child of this node
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def set_left_most(self, value: Union[&#39;Operator&#39;, Value]):
        &#34;&#34;&#34;
        Set the left most child of this node
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def set_right_most(self, value: Union[&#39;Operator&#39;, Value]):
        &#34;&#34;&#34;
        Set the right most child of this node
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Convert back to string for debugging
        &#34;&#34;&#34; 
        pass

    @abc.abstractmethod
    def to_search_query(self) -&gt; Dict:
        &#34;&#34;&#34;
        Recursively convert this node and it&#39;s children to a MongoDB query
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="app.search_parser.BinaryOperator" href="#app.search_parser.BinaryOperator">BinaryOperator</a></li>
<li><a title="app.search_parser.UnitaryOperator" href="#app.search_parser.UnitaryOperator">UnitaryOperator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.Operator.op_type"><code class="name">var <span class="ident">op_type</span> : <a title="app.search_parser.OperatorTypes" href="#app.search_parser.OperatorTypes">OperatorTypes</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="app.search_parser.Operator.get_left_most"><code class="name flex">
<span>def <span class="ident">get_left_most</span></span>(<span>self) ‑> Union[<a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a>, <a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the left most child of this node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_left_most(self) -&gt; Union[&#39;Operator&#39;, Value]:
    &#34;&#34;&#34;
    Get the left most child of this node
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="app.search_parser.Operator.get_right_most"><code class="name flex">
<span>def <span class="ident">get_right_most</span></span>(<span>self) ‑> Union[<a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a>, <a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the right most child of this node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_right_most(self) -&gt; Union[&#39;Operator&#39;, Value]:
    &#34;&#34;&#34;
    Get the right most child of this node
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="app.search_parser.Operator.set_left_most"><code class="name flex">
<span>def <span class="ident">set_left_most</span></span>(<span>self, value: Union[_ForwardRef('<a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a>'), <a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Set the left most child of this node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def set_left_most(self, value: Union[&#39;Operator&#39;, Value]):
    &#34;&#34;&#34;
    Set the left most child of this node
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="app.search_parser.Operator.set_right_most"><code class="name flex">
<span>def <span class="ident">set_right_most</span></span>(<span>self, value: Union[_ForwardRef('<a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a>'), <a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Set the right most child of this node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def set_right_most(self, value: Union[&#39;Operator&#39;, Value]):
    &#34;&#34;&#34;
    Set the right most child of this node
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="app.search_parser.Operator.to_search_query"><code class="name flex">
<span>def <span class="ident">to_search_query</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively convert this node and it's children to a MongoDB query</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def to_search_query(self) -&gt; Dict:
    &#34;&#34;&#34;
    Recursively convert this node and it&#39;s children to a MongoDB query
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="app.search_parser.OperatorTypes"><code class="flex name class">
<span>class <span class="ident">OperatorTypes</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enum to enumerate the different types of operator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OperatorTypes(Enum):
    &#34;&#34;&#34;
    An enum to enumerate the different types of operator
    &#34;&#34;&#34;

    Identity = &#34;identity&#34;
    Not = &#34;not&#34;
    And = &#34;and&#34;
    Or = &#34;or&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.OperatorTypes.And"><code class="name">var <span class="ident">And</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.OperatorTypes.Identity"><code class="name">var <span class="ident">Identity</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.OperatorTypes.Not"><code class="name">var <span class="ident">Not</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.OperatorTypes.Or"><code class="name">var <span class="ident">Or</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="app.search_parser.Parentheses"><code class="flex name class">
<span>class <span class="ident">Parentheses</span></span>
<span>(</span><span>start: int, end: int, inner: List[_ForwardRef('<a title="app.search_parser.Parentheses" href="#app.search_parser.Parentheses">Parentheses</a>')])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Parentheses:
    start: int = -1
    end: int = -1
    inner: List[&#39;Parentheses&#39;] = []

    def __init__(self, start: int, end: int, inner: List[&#39;Parentheses&#39;]):
        self.start = start
        self.end = end
        self.inner = inner

    def __str__(self) -&gt; str:
        inner_str = &#34;&#34;

        first = True
        for i in self.inner:
            if first:
                first = False
            else:
                inner_str += &#34;, &#34;
            inner_str += str(i)

        return &#34;Parentheses: start = &#34; + str(self.start) + &#34;, end = &#34; + str(self.end) + &#34;, inner = [&#34; + inner_str + &#34;]&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.Parentheses.end"><code class="name">var <span class="ident">end</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.Parentheses.inner"><code class="name">var <span class="ident">inner</span> : List[<a title="app.search_parser.Parentheses" href="#app.search_parser.Parentheses">Parentheses</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.Parentheses.start"><code class="name">var <span class="ident">start</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="app.search_parser.SearchStringParseError"><code class="flex name class">
<span>class <span class="ident">SearchStringParseError</span></span>
</code></dt>
<dd>
<div class="desc"><p>A base class used to repersent the a general error that might
be returned by the parser</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SearchStringParseError:
    &#34;&#34;&#34;
    A base class used to repersent the a general error that might 
    be returned by the parser
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return &#34;SearchStringParseError: &#34;

    def __repr__(self) -&gt; str:
        return self.__str__()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="app.search_parser.MissingCloseBracket" href="#app.search_parser.MissingCloseBracket">MissingCloseBracket</a></li>
<li><a title="app.search_parser.NonexistentAttribute" href="#app.search_parser.NonexistentAttribute">NonexistentAttribute</a></li>
<li><a title="app.search_parser.NonexistentTag" href="#app.search_parser.NonexistentTag">NonexistentTag</a></li>
<li><a title="app.search_parser.UnexpectedCloseBracket" href="#app.search_parser.UnexpectedCloseBracket">UnexpectedCloseBracket</a></li>
<li><a title="app.search_parser.UnexpectedOperator" href="#app.search_parser.UnexpectedOperator">UnexpectedOperator</a></li>
<li><a title="app.search_parser.UnexpectedTag" href="#app.search_parser.UnexpectedTag">UnexpectedTag</a></li>
</ul>
</dd>
<dt id="app.search_parser.TagValue"><code class="flex name class">
<span>class <span class="ident">TagValue</span></span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of Value, for the specific case where the atom is
a tag, like 'a'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TagValue(Value):
    &#34;&#34;&#34;
    A subclass of Value, for the specific case where the atom is 
    a tag, like &#39;a&#39;
    &#34;&#34;&#34;
    stripped_name: str
    tag_id: Optional[ObjectId] = None

    def __str__(self) -&gt; str:
        return super().__str__()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="app.search_parser.InstanceTagValue" href="#app.search_parser.InstanceTagValue">InstanceTagValue</a></li>
<li><a title="app.search_parser.ItemTagValue" href="#app.search_parser.ItemTagValue">ItemTagValue</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.TagValue.stripped_name"><code class="name">var <span class="ident">stripped_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.TagValue.tag_id"><code class="name">var <span class="ident">tag_id</span> : Union[bson.objectid.ObjectId, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a></b></code>:
<ul class="hlist">
<li><code><a title="app.search_parser.Value.parse" href="#app.search_parser.Value.parse">parse</a></code></li>
<li><code><a title="app.search_parser.Value.to_search_query" href="#app.search_parser.Value.to_search_query">to_search_query</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="app.search_parser.UnexpectedCloseBracket"><code class="flex name class">
<span>class <span class="ident">UnexpectedCloseBracket</span></span>
<span>(</span><span>index: int, bracket: <a title="app.search_parser.Brackets" href="#app.search_parser.Brackets">Brackets</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of SearchStringParseError, for the specific instance
where a close baracket (either } or )) was encountered in an
illegal/unexpected position such as '(a ::and b))'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnexpectedCloseBracket(SearchStringParseError):
    &#34;&#34;&#34;
    A subclass of SearchStringParseError, for the specific instance 
    where a close baracket (either } or )) was encountered in an 
    illegal/unexpected position such as &#39;(a ::and b))&#39;
    &#34;&#34;&#34;

    def __init__(self, index: int, bracket: Brackets):
        self.index = index
        self.bracket = bracket

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Unexpected &#39;&#34; + self.bracket.value[2] + &#34;&#39; at index: &#34; + str(self.index)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.SearchStringParseError" href="#app.search_parser.SearchStringParseError">SearchStringParseError</a></li>
</ul>
</dd>
<dt id="app.search_parser.UnexpectedOperator"><code class="flex name class">
<span>class <span class="ident">UnexpectedOperator</span></span>
<span>(</span><span>index: int, operator: <a title="app.search_parser.OperatorTypes" href="#app.search_parser.OperatorTypes">OperatorTypes</a>, alias=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of SearchStringParseError, for the specific instance
where an operator such as ::and occurs in an unexpected locations
such as: 'a ::and ::and b'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnexpectedOperator(SearchStringParseError):
    &#34;&#34;&#34;
    A subclass of SearchStringParseError, for the specific instance 
    where an operator such as ::and occurs in an unexpected locations 
    such as: &#39;a ::and ::and b&#39;
    &#34;&#34;&#34;

    def __init__(self, index: int, operator: &#39;OperatorTypes&#39;, alias=None):
        self.index = index
        if alias is None or not alias:
            self.operator_str = &#34;::&#34; + str(operator.value)
        else:
            self.operator_str = alias

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Unexpected operator: [&#34; + self.operator_str + &#34;] at index: &#34; + str(self.index)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.SearchStringParseError" href="#app.search_parser.SearchStringParseError">SearchStringParseError</a></li>
</ul>
</dd>
<dt id="app.search_parser.UnexpectedTag"><code class="flex name class">
<span>class <span class="ident">UnexpectedTag</span></span>
<span>(</span><span>index: int, string: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of SearchStringParseError, for the specific instance
where a tag appears in the wrong spot such as: 'a ::not b'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnexpectedTag(SearchStringParseError):
    &#34;&#34;&#34;
    A subclass of SearchStringParseError, for the specific instance 
    where a tag appears in the wrong spot such as: &#39;a ::not b&#39;
    &#34;&#34;&#34;

    def __init__(self, index: int, string: str):
        self.index = index
        self.string = string

    def __str__(self) -&gt; str:
        return super().__str__() + &#34;Unexpected tag: [&#34; + self.string + &#34;] at index: &#34; + str(self.index)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.SearchStringParseError" href="#app.search_parser.SearchStringParseError">SearchStringParseError</a></li>
</ul>
</dd>
<dt id="app.search_parser.UnitaryOperator"><code class="flex name class">
<span>class <span class="ident">UnitaryOperator</span></span>
<span>(</span><span>op_type: <a title="app.search_parser.OperatorTypes" href="#app.search_parser.OperatorTypes">OperatorTypes</a>, value: Union[<a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a>, <a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>A subclass of Operator for the specific instance of an operator
that takes in one value, such as 'not' or the unity operator '()'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnitaryOperator(Operator):
    &#34;&#34;&#34;
    A subclass of Operator for the specific instance of an operator 
    that takes in one value, such as &#39;not&#39; or the unity operator &#39;()&#39;
    &#34;&#34;&#34;
    value: Union[Operator, Value]

    def __init__(self, op_type: OperatorTypes, value: Union[Operator, Value]):
        super().__init__(op_type)

        self.value = value

    def get_left_most(self) -&gt; Union[Operator, Value]:
        &#34;&#34;&#34;
        Get the left most child of this node
        &#34;&#34;&#34;
        return self.value

    def get_right_most(self) -&gt; Union[Operator, Value]:
        &#34;&#34;&#34;
        Get the right most child of this node
        &#34;&#34;&#34;
        return self.value

    def set_left_most(self, value: Union[Operator, Value]):
        &#34;&#34;&#34;
        Set the left most child of this node
        &#34;&#34;&#34;
        self.value = value

    def set_right_most(self, value: Union[Operator, Value]):
        &#34;&#34;&#34;
        Set the right most child of this node
        &#34;&#34;&#34;
        self.value = value

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Convert back to string for debugging
        &#34;&#34;&#34;
        if self.op_type == OperatorTypes.Identity:
            return &#34;(&#34; + str(self.value) + &#34;)&#34;
        else:
            return &#34;::not &#34; + str(self.value)

    def to_search_query(self) -&gt; Dict:
        &#34;&#34;&#34;
        Recursively convert this node and it&#39;s children to a MongoDB query
        &#34;&#34;&#34;
        if self.op_type == OperatorTypes.Identity:
            return self.value.to_search_query()
        else:
            return {&#34;NOTE&#34;: &#34;Should never be reached&#34;}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.UnitaryOperator.value"><code class="name">var <span class="ident">value</span> : Union[<a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a>, <a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a></b></code>:
<ul class="hlist">
<li><code><a title="app.search_parser.Operator.get_left_most" href="#app.search_parser.Operator.get_left_most">get_left_most</a></code></li>
<li><code><a title="app.search_parser.Operator.get_right_most" href="#app.search_parser.Operator.get_right_most">get_right_most</a></code></li>
<li><code><a title="app.search_parser.Operator.set_left_most" href="#app.search_parser.Operator.set_left_most">set_left_most</a></code></li>
<li><code><a title="app.search_parser.Operator.set_right_most" href="#app.search_parser.Operator.set_right_most">set_right_most</a></code></li>
<li><code><a title="app.search_parser.Operator.to_search_query" href="#app.search_parser.Operator.to_search_query">to_search_query</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="app.search_parser.Value"><code class="flex name class">
<span>class <span class="ident">Value</span></span>
</code></dt>
<dd>
<div class="desc"><p>An general 'atom' of an expression, such as 'a' or
'::instance::uuid::equals::10202901'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Value:
    &#34;&#34;&#34;
    An general &#39;atom&#39; of an expression, such as &#39;a&#39; or 
    &#39;::instance::uuid::equals::10202901&#39;
    &#34;&#34;&#34;

    string: str
    not_value: bool = False

    @staticmethod
    def parse(value: str) -&gt; Union[&#39;Value&#39;, SearchStringParseError]:
        &#34;&#34;&#34;
        Given a string, that is suppose to figure out which kind 
        of atom/value it is and parse that into it&#39;s types
        &#34;&#34;&#34;

        if value.lstrip().startswith(&#34;::&#34;):

            if value.lstrip().startswith(&#34;::has::&#34;):
                cls = HasItemAttributeValue()
                cls.string = value
                cls.attribute_name = value.lstrip()[len(&#34;::has::&#34;):].rstrip().lower()

                return cls
            elif value.lstrip().startswith(&#34;::instance::has::&#34;):
                cls = HasInstanceAttributeValue()
                cls.string = value
                cls.attribute_name = value.lstrip()[len(&#34;::instance::has::&#34;):].rstrip().lstrip()

                return cls
            elif value.lstrip().startswith(&#34;::instance::&#34;):
                remain = value.lstrip()[len(&#34;::instance::&#34;):].rstrip()

                if &#34;::equals::&#34; in remain:
                    s = remain.find(&#34;::equals::&#34;)

                    cls = CheckInstanceAttributeValue()
                    cls.string = value
                    cls.attribute_name = remain[:s].lower()
                    cls.value = remain[s + len(&#34;::equals::&#34;):]
                    cls.check_mode = CheckMode.Equals

                    return cls
                elif &#34;::contains::&#34; in remain:
                    s = remain.find(&#34;::contains::&#34;)

                    cls = CheckInstanceAttributeValue()
                    cls.string = value
                    cls.attribute_name = remain[:s].lower()
                    cls.value = remain[s + len(&#34;::contains::&#34;):]
                    cls.check_mode = CheckMode.Contains

                    return cls
                else:
                    cls = InstanceTagValue()
                    cls.string = value
                    cls.stripped_name = remain.strip().lower()

                    return cls

            else:
                remain = value.lstrip()[len(&#34;::&#34;):].rstrip()

                if &#34;::equals::&#34; in remain:
                    s = remain.find(&#34;::equals::&#34;)

                    cls = CheckItemAttributeValue()
                    cls.string = value
                    cls.attribute_name = remain[:s].lower()
                    cls.value = remain[s + len(&#34;::equals::&#34;):]
                    cls.check_mode = CheckMode.Equals

                    return cls
                elif &#34;::contains::&#34; in remain:
                    s = remain.find(&#34;::contains::&#34;)

                    cls = CheckItemAttributeValue()
                    cls.string = value
                    cls.attribute_name = remain[:s].lower()
                    cls.value = remain[s + len(&#34;::contains::&#34;):]
                    cls.check_mode = CheckMode.Contains

                    return cls

        else:
            cls = ItemTagValue()
            cls.string = value
            cls.stripped_name = value.strip().lower()

            return cls

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Convert the atom back into a string, for testing
        &#34;&#34;&#34;
        if self.not_value:
            return &#34;!&#34;
        return &#34;&#34;

    def to_search_query(self) -&gt; Dict:
        &#34;&#34;&#34;
        Take the value/atom and convert it into a MongoDB search 
        query for that specific information
        &#34;&#34;&#34;
        if isinstance(self, ItemTagValue):
            if self.not_value:
                inner = {&#34;$ne&#34;: self.tag_id}
                op = &#34;$and&#34;
            else:
                inner = self.tag_id
                op = &#34;$or&#34;

            return {op: [{&#34;tags&#34;: inner}, {&#34;implied_tags&#34;: inner}]}
        elif isinstance(self, InstanceTagValue):
            if self.not_value:
                inner = {&#34;$ne&#34;: self.tag_id}
                op = &#34;$and&#34;
            else:
                inner = self.tag_id
                op = &#34;$or&#34;

            return {op: [{&#34;instances.tags&#34;: inner}, {&#34;instances.implied_tags&#34;: inner}]}
        elif isinstance(self, HasItemAttributeValue):
            if self.not_value:
                return {&#34;attributes.option_id&#34;: {&#34;$ne&#34;: self.attribute_option_id}}
            else:
                return {&#34;attributes.option_id&#34;: self.attribute_option_id}
        elif isinstance(self, HasInstanceAttributeValue):
            if self.not_value:
                return {&#34;instances.attributes.option_id&#34;: {&#34;$ne&#34;: self.attribute_option_id}}
            else:
                return {&#34;instances.attributes.option_id&#34;: self.attribute_option_id}
        elif isinstance(self, VisibleItemValue):
            return {&#34;hidden&#34;: {&#34;$ne&#34;: True}}
        elif isinstance(self, CheckItemAttributeValue):
            if self.check_mode == CheckMode.Equals:
                if self.not_value:
                    return {&#34;attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;$ne&#34;: self.value}}}}
                else:
                    return {&#34;attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: self.value}}}
            elif self.check_mode == CheckMode.Contains:
                if self.not_value:
                    return {&#34;attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;not&#34;: {&#34;$regex&#34;: &#34;.*&#34; + self.value + &#34;.*&#34;}}}}}
                else:
                    return {&#34;attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;$regex&#34;: &#34;.*&#34; + self.value + &#34;.*&#34;}}}}
            else:
                return {&#34;TODO&#34;: &#34;Unexpected&#34;}
        elif isinstance(self, CheckInstanceAttributeValue):
            if self.check_mode == CheckMode.Equals:
                if self.not_value:
                    return {&#34;instances.attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;$ne&#34;: self.value}}}}
                else:
                    return {&#34;instances.attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: self.value}}}
            elif self.check_mode == CheckMode.Contains:
                if self.not_value:
                    return {&#34;instances.attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;not&#34;: {&#34;$regex&#34;: &#34;.*&#34; + self.value + &#34;.*&#34;}}}}}
                else:
                    return {&#34;instances.attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;$regex&#34;: &#34;.*&#34; + self.value + &#34;.*&#34;}}}}
            else:
                return {&#34;TODO&#34;: &#34;Unexpected&#34;}</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="app.search_parser.AttributeValue" href="#app.search_parser.AttributeValue">AttributeValue</a></li>
<li><a title="app.search_parser.TagValue" href="#app.search_parser.TagValue">TagValue</a></li>
<li><a title="app.search_parser.VisibleItemValue" href="#app.search_parser.VisibleItemValue">VisibleItemValue</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.Value.not_value"><code class="name">var <span class="ident">not_value</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.Value.string"><code class="name">var <span class="ident">string</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="app.search_parser.Value.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>value: str) ‑> Union[<a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a>, <a title="app.search_parser.SearchStringParseError" href="#app.search_parser.SearchStringParseError">SearchStringParseError</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Given a string, that is suppose to figure out which kind
of atom/value it is and parse that into it's types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(value: str) -&gt; Union[&#39;Value&#39;, SearchStringParseError]:
    &#34;&#34;&#34;
    Given a string, that is suppose to figure out which kind 
    of atom/value it is and parse that into it&#39;s types
    &#34;&#34;&#34;

    if value.lstrip().startswith(&#34;::&#34;):

        if value.lstrip().startswith(&#34;::has::&#34;):
            cls = HasItemAttributeValue()
            cls.string = value
            cls.attribute_name = value.lstrip()[len(&#34;::has::&#34;):].rstrip().lower()

            return cls
        elif value.lstrip().startswith(&#34;::instance::has::&#34;):
            cls = HasInstanceAttributeValue()
            cls.string = value
            cls.attribute_name = value.lstrip()[len(&#34;::instance::has::&#34;):].rstrip().lstrip()

            return cls
        elif value.lstrip().startswith(&#34;::instance::&#34;):
            remain = value.lstrip()[len(&#34;::instance::&#34;):].rstrip()

            if &#34;::equals::&#34; in remain:
                s = remain.find(&#34;::equals::&#34;)

                cls = CheckInstanceAttributeValue()
                cls.string = value
                cls.attribute_name = remain[:s].lower()
                cls.value = remain[s + len(&#34;::equals::&#34;):]
                cls.check_mode = CheckMode.Equals

                return cls
            elif &#34;::contains::&#34; in remain:
                s = remain.find(&#34;::contains::&#34;)

                cls = CheckInstanceAttributeValue()
                cls.string = value
                cls.attribute_name = remain[:s].lower()
                cls.value = remain[s + len(&#34;::contains::&#34;):]
                cls.check_mode = CheckMode.Contains

                return cls
            else:
                cls = InstanceTagValue()
                cls.string = value
                cls.stripped_name = remain.strip().lower()

                return cls

        else:
            remain = value.lstrip()[len(&#34;::&#34;):].rstrip()

            if &#34;::equals::&#34; in remain:
                s = remain.find(&#34;::equals::&#34;)

                cls = CheckItemAttributeValue()
                cls.string = value
                cls.attribute_name = remain[:s].lower()
                cls.value = remain[s + len(&#34;::equals::&#34;):]
                cls.check_mode = CheckMode.Equals

                return cls
            elif &#34;::contains::&#34; in remain:
                s = remain.find(&#34;::contains::&#34;)

                cls = CheckItemAttributeValue()
                cls.string = value
                cls.attribute_name = remain[:s].lower()
                cls.value = remain[s + len(&#34;::contains::&#34;):]
                cls.check_mode = CheckMode.Contains

                return cls

    else:
        cls = ItemTagValue()
        cls.string = value
        cls.stripped_name = value.strip().lower()

        return cls</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="app.search_parser.Value.to_search_query"><code class="name flex">
<span>def <span class="ident">to_search_query</span></span>(<span>self) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Take the value/atom and convert it into a MongoDB search
query for that specific information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_search_query(self) -&gt; Dict:
    &#34;&#34;&#34;
    Take the value/atom and convert it into a MongoDB search 
    query for that specific information
    &#34;&#34;&#34;
    if isinstance(self, ItemTagValue):
        if self.not_value:
            inner = {&#34;$ne&#34;: self.tag_id}
            op = &#34;$and&#34;
        else:
            inner = self.tag_id
            op = &#34;$or&#34;

        return {op: [{&#34;tags&#34;: inner}, {&#34;implied_tags&#34;: inner}]}
    elif isinstance(self, InstanceTagValue):
        if self.not_value:
            inner = {&#34;$ne&#34;: self.tag_id}
            op = &#34;$and&#34;
        else:
            inner = self.tag_id
            op = &#34;$or&#34;

        return {op: [{&#34;instances.tags&#34;: inner}, {&#34;instances.implied_tags&#34;: inner}]}
    elif isinstance(self, HasItemAttributeValue):
        if self.not_value:
            return {&#34;attributes.option_id&#34;: {&#34;$ne&#34;: self.attribute_option_id}}
        else:
            return {&#34;attributes.option_id&#34;: self.attribute_option_id}
    elif isinstance(self, HasInstanceAttributeValue):
        if self.not_value:
            return {&#34;instances.attributes.option_id&#34;: {&#34;$ne&#34;: self.attribute_option_id}}
        else:
            return {&#34;instances.attributes.option_id&#34;: self.attribute_option_id}
    elif isinstance(self, VisibleItemValue):
        return {&#34;hidden&#34;: {&#34;$ne&#34;: True}}
    elif isinstance(self, CheckItemAttributeValue):
        if self.check_mode == CheckMode.Equals:
            if self.not_value:
                return {&#34;attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;$ne&#34;: self.value}}}}
            else:
                return {&#34;attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: self.value}}}
        elif self.check_mode == CheckMode.Contains:
            if self.not_value:
                return {&#34;attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;not&#34;: {&#34;$regex&#34;: &#34;.*&#34; + self.value + &#34;.*&#34;}}}}}
            else:
                return {&#34;attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;$regex&#34;: &#34;.*&#34; + self.value + &#34;.*&#34;}}}}
        else:
            return {&#34;TODO&#34;: &#34;Unexpected&#34;}
    elif isinstance(self, CheckInstanceAttributeValue):
        if self.check_mode == CheckMode.Equals:
            if self.not_value:
                return {&#34;instances.attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;$ne&#34;: self.value}}}}
            else:
                return {&#34;instances.attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: self.value}}}
        elif self.check_mode == CheckMode.Contains:
            if self.not_value:
                return {&#34;instances.attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;not&#34;: {&#34;$regex&#34;: &#34;.*&#34; + self.value + &#34;.*&#34;}}}}}
            else:
                return {&#34;instances.attributes&#34;: {&#34;$elemMatch&#34;: {&#34;option_id&#34;: self.attribute_option_id, &#34;value&#34;: {&#34;$regex&#34;: &#34;.*&#34; + self.value + &#34;.*&#34;}}}}
        else:
            return {&#34;TODO&#34;: &#34;Unexpected&#34;}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="app.search_parser.VisibleItemValue"><code class="flex name class">
<span>class <span class="ident">VisibleItemValue</span></span>
</code></dt>
<dd>
<div class="desc"><p>A special subclass of Value, used internally to tell the DB to only
provide visible visible items/instances from the DB</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VisibleItemValue(Value):
    &#34;&#34;&#34;
    A special subclass of Value, used internally to tell the DB to only 
    provide visible visible items/instances from the DB
    &#34;&#34;&#34;

    def __str__(self) -&gt; str:
        return &#34;VisibleItem&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="app.search_parser.VisibleItemValue.not_value"><code class="name">var <span class="ident">not_value</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="app.search_parser.VisibleItemValue.string"><code class="name">var <span class="ident">string</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a></b></code>:
<ul class="hlist">
<li><code><a title="app.search_parser.Value.parse" href="#app.search_parser.Value.parse">parse</a></code></li>
<li><code><a title="app.search_parser.Value.to_search_query" href="#app.search_parser.Value.to_search_query">to_search_query</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="app" href="index.html">app</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="app.search_parser.search_string_lexer" href="#app.search_parser.search_string_lexer">search_string_lexer</a></code></li>
<li><code><a title="app.search_parser.search_string_parser" href="#app.search_parser.search_string_parser">search_string_parser</a></code></li>
<li><code><a title="app.search_parser.search_string_to_mongodb_query" href="#app.search_parser.search_string_to_mongodb_query">search_string_to_mongodb_query</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="app.search_parser.AST" href="#app.search_parser.AST">AST</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.AST.attribute_values" href="#app.search_parser.AST.attribute_values">attribute_values</a></code></li>
<li><code><a title="app.search_parser.AST.base_operator" href="#app.search_parser.AST.base_operator">base_operator</a></code></li>
<li><code><a title="app.search_parser.AST.tag_values" href="#app.search_parser.AST.tag_values">tag_values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.AttributeValue" href="#app.search_parser.AttributeValue">AttributeValue</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.AttributeValue.attribute_name" href="#app.search_parser.AttributeValue.attribute_name">attribute_name</a></code></li>
<li><code><a title="app.search_parser.AttributeValue.attribute_option_id" href="#app.search_parser.AttributeValue.attribute_option_id">attribute_option_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.BinaryOperator" href="#app.search_parser.BinaryOperator">BinaryOperator</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.BinaryOperator.left_value" href="#app.search_parser.BinaryOperator.left_value">left_value</a></code></li>
<li><code><a title="app.search_parser.BinaryOperator.right_value" href="#app.search_parser.BinaryOperator.right_value">right_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.Brackets" href="#app.search_parser.Brackets">Brackets</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.Brackets.Curly" href="#app.search_parser.Brackets.Curly">Curly</a></code></li>
<li><code><a title="app.search_parser.Brackets.Parentheses" href="#app.search_parser.Brackets.Parentheses">Parentheses</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.CheckInstanceAttributeValue" href="#app.search_parser.CheckInstanceAttributeValue">CheckInstanceAttributeValue</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.CheckInstanceAttributeValue.check_mode" href="#app.search_parser.CheckInstanceAttributeValue.check_mode">check_mode</a></code></li>
<li><code><a title="app.search_parser.CheckInstanceAttributeValue.value" href="#app.search_parser.CheckInstanceAttributeValue.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.CheckItemAttributeValue" href="#app.search_parser.CheckItemAttributeValue">CheckItemAttributeValue</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.CheckItemAttributeValue.check_mode" href="#app.search_parser.CheckItemAttributeValue.check_mode">check_mode</a></code></li>
<li><code><a title="app.search_parser.CheckItemAttributeValue.value" href="#app.search_parser.CheckItemAttributeValue.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.CheckMode" href="#app.search_parser.CheckMode">CheckMode</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.CheckMode.Contains" href="#app.search_parser.CheckMode.Contains">Contains</a></code></li>
<li><code><a title="app.search_parser.CheckMode.Equals" href="#app.search_parser.CheckMode.Equals">Equals</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.HasInstanceAttributeValue" href="#app.search_parser.HasInstanceAttributeValue">HasInstanceAttributeValue</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.HasInstanceAttributeValue.attribute_name" href="#app.search_parser.HasInstanceAttributeValue.attribute_name">attribute_name</a></code></li>
<li><code><a title="app.search_parser.HasInstanceAttributeValue.attribute_option_id" href="#app.search_parser.HasInstanceAttributeValue.attribute_option_id">attribute_option_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.HasItemAttributeValue" href="#app.search_parser.HasItemAttributeValue">HasItemAttributeValue</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.HasItemAttributeValue.attribute_name" href="#app.search_parser.HasItemAttributeValue.attribute_name">attribute_name</a></code></li>
<li><code><a title="app.search_parser.HasItemAttributeValue.attribute_option_id" href="#app.search_parser.HasItemAttributeValue.attribute_option_id">attribute_option_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.InstanceTagValue" href="#app.search_parser.InstanceTagValue">InstanceTagValue</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.InstanceTagValue.stripped_name" href="#app.search_parser.InstanceTagValue.stripped_name">stripped_name</a></code></li>
<li><code><a title="app.search_parser.InstanceTagValue.tag_id" href="#app.search_parser.InstanceTagValue.tag_id">tag_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.ItemTagValue" href="#app.search_parser.ItemTagValue">ItemTagValue</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.ItemTagValue.stripped_name" href="#app.search_parser.ItemTagValue.stripped_name">stripped_name</a></code></li>
<li><code><a title="app.search_parser.ItemTagValue.tag_id" href="#app.search_parser.ItemTagValue.tag_id">tag_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.LexerSymbol" href="#app.search_parser.LexerSymbol">LexerSymbol</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.LexerSymbol.end_index" href="#app.search_parser.LexerSymbol.end_index">end_index</a></code></li>
<li><code><a title="app.search_parser.LexerSymbol.start_index" href="#app.search_parser.LexerSymbol.start_index">start_index</a></code></li>
<li><code><a title="app.search_parser.LexerSymbol.symbol_type" href="#app.search_parser.LexerSymbol.symbol_type">symbol_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.LexerSymbolTypes" href="#app.search_parser.LexerSymbolTypes">LexerSymbolTypes</a></code></h4>
<ul class="two-column">
<li><code><a title="app.search_parser.LexerSymbolTypes.AND" href="#app.search_parser.LexerSymbolTypes.AND">AND</a></code></li>
<li><code><a title="app.search_parser.LexerSymbolTypes.ESCAPE_CLOSE" href="#app.search_parser.LexerSymbolTypes.ESCAPE_CLOSE">ESCAPE_CLOSE</a></code></li>
<li><code><a title="app.search_parser.LexerSymbolTypes.ESCAPE_OPEN" href="#app.search_parser.LexerSymbolTypes.ESCAPE_OPEN">ESCAPE_OPEN</a></code></li>
<li><code><a title="app.search_parser.LexerSymbolTypes.IGNORE" href="#app.search_parser.LexerSymbolTypes.IGNORE">IGNORE</a></code></li>
<li><code><a title="app.search_parser.LexerSymbolTypes.NOT" href="#app.search_parser.LexerSymbolTypes.NOT">NOT</a></code></li>
<li><code><a title="app.search_parser.LexerSymbolTypes.OR" href="#app.search_parser.LexerSymbolTypes.OR">OR</a></code></li>
<li><code><a title="app.search_parser.LexerSymbolTypes.PAREN_CLOSE" href="#app.search_parser.LexerSymbolTypes.PAREN_CLOSE">PAREN_CLOSE</a></code></li>
<li><code><a title="app.search_parser.LexerSymbolTypes.PAREN_OPEN" href="#app.search_parser.LexerSymbolTypes.PAREN_OPEN">PAREN_OPEN</a></code></li>
<li><code><a title="app.search_parser.LexerSymbolTypes.TAG" href="#app.search_parser.LexerSymbolTypes.TAG">TAG</a></code></li>
<li><code><a title="app.search_parser.LexerSymbolTypes.from_str" href="#app.search_parser.LexerSymbolTypes.from_str">from_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.MissingCloseBracket" href="#app.search_parser.MissingCloseBracket">MissingCloseBracket</a></code></h4>
</li>
<li>
<h4><code><a title="app.search_parser.NonexistentAttribute" href="#app.search_parser.NonexistentAttribute">NonexistentAttribute</a></code></h4>
</li>
<li>
<h4><code><a title="app.search_parser.NonexistentTag" href="#app.search_parser.NonexistentTag">NonexistentTag</a></code></h4>
</li>
<li>
<h4><code><a title="app.search_parser.Operator" href="#app.search_parser.Operator">Operator</a></code></h4>
<ul class="two-column">
<li><code><a title="app.search_parser.Operator.get_left_most" href="#app.search_parser.Operator.get_left_most">get_left_most</a></code></li>
<li><code><a title="app.search_parser.Operator.get_right_most" href="#app.search_parser.Operator.get_right_most">get_right_most</a></code></li>
<li><code><a title="app.search_parser.Operator.op_type" href="#app.search_parser.Operator.op_type">op_type</a></code></li>
<li><code><a title="app.search_parser.Operator.set_left_most" href="#app.search_parser.Operator.set_left_most">set_left_most</a></code></li>
<li><code><a title="app.search_parser.Operator.set_right_most" href="#app.search_parser.Operator.set_right_most">set_right_most</a></code></li>
<li><code><a title="app.search_parser.Operator.to_search_query" href="#app.search_parser.Operator.to_search_query">to_search_query</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.OperatorTypes" href="#app.search_parser.OperatorTypes">OperatorTypes</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.OperatorTypes.And" href="#app.search_parser.OperatorTypes.And">And</a></code></li>
<li><code><a title="app.search_parser.OperatorTypes.Identity" href="#app.search_parser.OperatorTypes.Identity">Identity</a></code></li>
<li><code><a title="app.search_parser.OperatorTypes.Not" href="#app.search_parser.OperatorTypes.Not">Not</a></code></li>
<li><code><a title="app.search_parser.OperatorTypes.Or" href="#app.search_parser.OperatorTypes.Or">Or</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.Parentheses" href="#app.search_parser.Parentheses">Parentheses</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.Parentheses.end" href="#app.search_parser.Parentheses.end">end</a></code></li>
<li><code><a title="app.search_parser.Parentheses.inner" href="#app.search_parser.Parentheses.inner">inner</a></code></li>
<li><code><a title="app.search_parser.Parentheses.start" href="#app.search_parser.Parentheses.start">start</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.SearchStringParseError" href="#app.search_parser.SearchStringParseError">SearchStringParseError</a></code></h4>
</li>
<li>
<h4><code><a title="app.search_parser.TagValue" href="#app.search_parser.TagValue">TagValue</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.TagValue.stripped_name" href="#app.search_parser.TagValue.stripped_name">stripped_name</a></code></li>
<li><code><a title="app.search_parser.TagValue.tag_id" href="#app.search_parser.TagValue.tag_id">tag_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.UnexpectedCloseBracket" href="#app.search_parser.UnexpectedCloseBracket">UnexpectedCloseBracket</a></code></h4>
</li>
<li>
<h4><code><a title="app.search_parser.UnexpectedOperator" href="#app.search_parser.UnexpectedOperator">UnexpectedOperator</a></code></h4>
</li>
<li>
<h4><code><a title="app.search_parser.UnexpectedTag" href="#app.search_parser.UnexpectedTag">UnexpectedTag</a></code></h4>
</li>
<li>
<h4><code><a title="app.search_parser.UnitaryOperator" href="#app.search_parser.UnitaryOperator">UnitaryOperator</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.UnitaryOperator.value" href="#app.search_parser.UnitaryOperator.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.Value" href="#app.search_parser.Value">Value</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.Value.not_value" href="#app.search_parser.Value.not_value">not_value</a></code></li>
<li><code><a title="app.search_parser.Value.parse" href="#app.search_parser.Value.parse">parse</a></code></li>
<li><code><a title="app.search_parser.Value.string" href="#app.search_parser.Value.string">string</a></code></li>
<li><code><a title="app.search_parser.Value.to_search_query" href="#app.search_parser.Value.to_search_query">to_search_query</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="app.search_parser.VisibleItemValue" href="#app.search_parser.VisibleItemValue">VisibleItemValue</a></code></h4>
<ul class="">
<li><code><a title="app.search_parser.VisibleItemValue.not_value" href="#app.search_parser.VisibleItemValue.not_value">not_value</a></code></li>
<li><code><a title="app.search_parser.VisibleItemValue.string" href="#app.search_parser.VisibleItemValue.string">string</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>